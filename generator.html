<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Choices.js for searchable dropdowns - Load with preconnect and preload -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js" as="script">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css" media="print" onload="this.media='all'">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, viewport-fit=cover">
    <meta name="theme-color" content="#3498db">
    <title>PowerBall Random Generator</title>
    <link rel="stylesheet" href="style.css" media="print" onload="this.media='all'">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <style>
      body {
        background: linear-gradient(120deg, #f0f4ff 0%, #fff 100%);
      }
      .generator-container {
        max-width: 900px;
        margin: 20px auto;
        background: #fff;
        border-radius: 16px;
        box-shadow: 0 4px 24px rgba(44,62,80,0.10);
        padding: 24px 16px;
        transition: all 0.3s ease;
        will-change: transform, box-shadow;
      }
      .generator-title {
        text-align: center;
        font-size: 2.1em;
        font-weight: 700;
        color: #234;
        margin-bottom: 18px;
        letter-spacing: 0.5px;
      }
      .generator-flex-layout {
        display: flex;
        flex-wrap: wrap;
        gap: 32px 24px;
        justify-content: center;
      }
      .generator-section {
        flex: 1 1 320px;
        min-width: 320px;
        max-width: 420px;
        margin-bottom: 0;
      }
      .generator-panel {
        background: #f8faff;
        border-radius: 14px;
        box-shadow: 0 2px 8px rgba(44,62,80,0.04);
        padding: 24px 18px 18px 18px;
        margin-bottom: 0;
      }
      .generator-panel h2 {
        font-size: 1.25em;
        font-weight: 600;
        color: #3498db;
        margin-bottom: 16px;
      }
      .multi-gen-btn, .freq-gen-btn, #build-duo-combo-btn, #build-combo-btn {
        background: linear-gradient(90deg, #3498db 0%, #6dd5fa 100%);
        color: #fff;
        border: none;
        border-radius: 8px;
        padding: 12px 18px;
        font-size: 1.08em;
        font-weight: 600;
        margin: 0 0 12px 0;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(44,62,80,0.08);
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
        min-height: 44px; /* Minimum touch target size */
        width: 100%;
        display: block;
      }
      .multi-gen-btn:hover, .freq-gen-btn:hover, #build-duo-combo-btn:hover, #build-combo-btn:hover {
        background: linear-gradient(90deg, #217dbb 0%, #3498db 100%);
        box-shadow: 0 4px 16px rgba(44,62,80,0.13);
      }
      /* Mobile-first responsive design */
      @media (max-width: 480px) {
        .generator-container {
          padding: 8px 4px 16px 4px;
          margin: 16px 8px;
          width: calc(100% - 24px);
          box-sizing: border-box;
        }
        .generator-title {
          font-size: 1.6em;
          padding: 0 8px;
        }
        .tab-nav {
          flex-wrap: wrap;
          padding: 6px 4px;
          gap: 6px;
        }
        .tab-btn {
          padding: 8px 12px;
          font-size: 1em;
          flex: 1 0 calc(50% - 12px);
          text-align: center;
        }
        .generator-panel {
          padding: 16px 12px;
          margin: 0 4px;
          width: calc(100% - 32px);
        }
        .multi-gen-btn, .freq-gen-btn, #build-duo-combo-btn, #build-combo-btn {
          width: 100%;
          margin: 0 0 10px 0;
          padding: 12px;
          font-size: 1.1em;
        }
        .pills-container {
          grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
          gap: 8px;
        }
      }

      @media (min-width: 481px) and (max-width: 768px) {
        .generator-container {
          padding: 16px 12px;
          margin: 20px 12px;
          width: calc(100% - 48px);
        }
        .generator-title {
          font-size: 1.8em;
        }
        .tab-btn {
          padding: 8px 14px;
          font-size: 1.05em;
        }
      }

      @media (min-width: 769px) {
        .generator-container {
          max-width: 900px;
          margin: 40px auto;
          padding: 32px 18px;
        }
      }
      .back-link {
        display: block;
        margin: 32px auto 0 auto;
        color: #3498db;
        font-weight: 600;
        text-decoration: none;
        text-align: center;
        width: 100%;
        font-size: 1.08em;
      }
      .tab-nav {
        display: flex;
        justify-content: center;
        gap: 0 18px;
        margin-bottom: 24px;
        background: #f8faff;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(44,62,80,0.04);
        padding: 10px 0;
      }
      .tab-btn {
        background: none;
        border: none;
        color: #234;
        font-size: 1.08em;
        font-weight: 600;
        padding: 8px 18px;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.13s, color 0.13s;
      }
      .tab-btn.active {
        background: linear-gradient(90deg, #3498db 0%, #6dd5fa 100%);
        color: #fff;
      }
      .tab-btn:not(.active):hover {
        background: #eaf3fb;
        color: #3498db;
      }
      /* Make all balls bold throughout the page */
      .generated-ball, .red-ball, .ball, .yellow-ball {
        font-weight: bold !important;
      }
      /* Make selection pills more visually clear */
      .pill-btn.selected {
        background: linear-gradient(90deg, #ffe066 0%, #e67e22 100%) !important;
        color: #222 !important;
        border: 2px solid #e67e22 !important;
        box-shadow: 0 0 0 3px #ffe06699, 0 2px 8px rgba(230, 126, 34, 0.13);
        font-weight: bold;
        outline: none;
      }
      /* Enhanced Section 2: Create Combination from 2 Duos */
      #duo-builder-panel {
        background: #f4faff;
        border-radius: 16px;
        box-shadow: 0 2px 12px rgba(52,152,219,0.08);
        padding: 28px 22px 22px 22px;
        margin-bottom: 0;
        max-width: 420px;
        margin-left: auto;
        margin-right: auto;
      }
      #duo-builder-panel h2 {
        color: #217dbb;
        font-size: 1.22em;
        font-weight: 700;
        margin-bottom: 18px;
        letter-spacing: 0.5px;
      }
      .duo-select-label {
        font-size: 1.07em;
        font-weight: 600;
        color: #234;
        margin-bottom: 6px;
        display: block;
      }
      .duo-select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 8px;
        border: 1.5px solid #b3d6f2;
        font-size: 1.08em;
        margin-bottom: 16px;
        background: #fff;
        transition: border 0.15s;
      }
      .duo-select:focus {
        border: 1.5px solid #3498db;
        outline: none;
      }
      #build-duo-combo-btn {
        width: 100%;
        font-size: 1.13em;
        padding: 12px 0;
        border-radius: 10px;
        margin-top: 10px;
        margin-bottom: 0;
      }
      #built-duo-combo-result {
        margin-top: 22px !important;
        background: #eaf6fb;
        border-radius: 10px;
        padding: 18px 12px;
        min-height: 36px;
        font-size: 1.09em;
        color: #234;
        box-shadow: 0 1px 4px rgba(52,152,219,0.07);
      }
      /* Pills container styling */
      /* Enhanced Pills Container */
      .pills-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 10px;
        margin: 12px 0 20px 0;
      }
      
      /* Pill Buttons */
      .pill-btn {
        background: #f0f7ff;
        border: 1px solid #d0e3ff;
        border-radius: 8px;
        padding: 8px 12px;
        font-size: 0.95em;
        color: #2c5282;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      
      .pill-btn:hover {
        background: #e1f0ff;
        transform: translateY(-1px);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      }
      
      .pill-btn.selected {
        background: #3182ce;
        color: white;
        border-color: #2c5282;
        font-weight: 600;
      }
      
      /* Section Headers */
      .section-header {
        font-size: 1.1em;
        font-weight: 600;
        color: #2d3748;
        margin: 20px 0 12px 0;
        padding-bottom: 8px;
        border-bottom: 2px solid #e2e8f0;
      }
      
      /* Frequency Badge */
      .frequency-badge {
        display: inline-block;
        background: #ebf8ff;
        color: #2b6cb0;
        font-size: 0.8em;
        padding: 2px 6px;
        border-radius: 10px;
        margin-left: 6px;
        font-weight: 600;
      }
      
      /* Responsive adjustments */
      @media (max-width: 768px) {
        .pills-container {
          grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        }
      }
      
      @media (max-width: 480px) {
        .pills-container {
          grid-template-columns: repeat(2, 1fr);
        }
      }
      
      /* Pill button styling */
      .pill-btn {
        background: #f0f7ff;
        border: 1.5px solid #cce0f7;
        border-radius: 16px;
        padding: 8px 14px;
        font-size: 0.95em;
        font-weight: 500;
        color: #2c3e50;
        cursor: pointer;
        transition: all 0.15s ease;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      }
      
      .pill-btn:hover {
        background: #e1f0ff;
        transform: translateY(-1px);
        box-shadow: 0 3px 8px rgba(0,0,0,0.08);
      }
      
      .pill-btn.selected {
        background: linear-gradient(135deg, #4a90e2 0%, #5ab0f4 100%);
        color: white;
        border-color: #3a7bc8;
        font-weight: 600;
        box-shadow: 0 2px 6px rgba(74, 144, 226, 0.25);
      }
      
      /* Section 3: Create Combination from 1 Duo and 1 Trio */
      #combo-builder-panel {
        background: #f9fcff;
        border-radius: 16px;
        box-shadow: 0 2px 12px rgba(74, 144, 226, 0.08);
        padding: 28px 22px 22px 22px;
        margin-top: 24px;
      }
      
      #combo-builder-panel h2 {
        color: #2c6aa0;
        font-size: 1.22em;
        font-weight: 700;
        margin-bottom: 18px;
        letter-spacing: 0.5px;
      }
      
      /* 2x Results Modern Style */
      .twox-combo-results-list {
        margin-top: 18px;
        background: #f8faff;
        border-radius: 14px;
        box-shadow: 0 2px 8px rgba(44,62,80,0.06);
        padding: 18px 14px 10px 14px;
        max-width: 480px;
        margin-left: auto;
        margin-right: auto;
      }
      .twox-combo-row {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 1.13em;
        margin-bottom: 10px;
        padding-bottom: 6px;
        border-bottom: 1px solid #e3eaf2;
      }
      .twox-combo-row:last-child {
        border-bottom: none;
      }
      .twox-combo-label {
        font-weight: 600;
        color: #217dbb;
        min-width: 140px;
        display: inline-block;
      }
      .twox-red-ball {
        display: inline-block;
        background: linear-gradient(120deg, #e74c3c 60%, #ffb3b3 100%);
        color: #fff;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        line-height: 32px;
        text-align: center;
        font-size: 1.08em;
        font-weight: bold;
        margin-right: 4px;
        box-shadow: 0 2px 8px rgba(231,76,60,0.10);
        border: 2px solid #e74c3c;
      }
      /* 2x Sets Interactive Panel and Results */
      #twox-interactive-panel {
        background: #f8faff;
        border-radius: 16px;
        box-shadow: 0 2px 12px rgba(52,152,219,0.08);
        padding: 24px 18px 18px 18px;
        margin-bottom: 24px;
        max-width: 480px;
        margin-left: auto;
        margin-right: auto;
      }
      #twox-ball-select {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 18px;
        justify-content: center;
      }
      .twox-ball {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: #fff;
        border: 2px solid #e74c3c;
        color: #e74c3c;
        font-weight: bold;
        font-size: 1.08em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.15s, color 0.15s, border 0.15s;
      }
      .twox-ball.selected {
        background: #e74c3c;
        color: #fff;
        border: 2px solid #c0392b;
        box-shadow: 0 2px 8px rgba(231,76,60,0.13);
      }
      #twox-results-panel {
        background: #f4faff;
        border-radius: 14px;
        box-shadow: 0 2px 8px rgba(52,152,219,0.07);
        padding: 18px 14px;
        margin-top: 18px;
        min-height: 60px;
      }
      .twox-combo-row {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 1.13em;
        margin-bottom: 10px;
        padding-bottom: 6px;
        border-bottom: 1px solid #e3eaf2;
      }
      .twox-combo-row:last-child {
        border-bottom: none;
      }
      .twox-combo-label {
        font-weight: 600;
        color: #217dbb;
        min-width: 170px;
        display: inline-block;
      }
      .twox-red-ball {
        display: inline-block;
        background: linear-gradient(120deg, #e74c3c 60%, #ffb3b3 100%);
        color: #fff;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        line-height: 32px;
        text-align: center;
        font-size: 1.08em;
        font-weight: bold;
        margin-right: 4px;
        box-shadow: 0 2px 8px rgba(231,76,60,0.10);
        border: 2px solid #e74c3c;
      }
    </style>
</head>
<body>
    <div class="generator-container">
      <div class="generator-title">Random Number Generator</div>
      <div id="home-tab" class="tab-content" style="display:block;">
      </div>
      <div id="history-tab" class="tab-content" style="display:none;">
        <div id="history-content"></div>
      </div>
      <div class="generator-flex-layout">
          <!-- Section 1: Quick Random Generator -->
          <section class="generator-section">
            <div class="generator-panel">
              <div style="margin-bottom: 18px;">
                <button id="generate-from-overlapping-trios" class="multi-gen-btn" style="background: #e74c3c; color: white; margin-bottom: 8px;">From Overlapping Trios</button>
                <button id="generate-enhanced-trios" class="multi-gen-btn" style="background: #27ae60; color: white; margin-bottom: 8px;">Enhanced Trio Generator</button>
                <button id="generate-patterned-trios" class="multi-gen-btn" style="background: #9b59b6; color: white;">Patterned Trio Generator</button>
              </div>
              <div id="generated-table" style="margin-top:18px; min-height: 200px; border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.05);"></div>
              <div id="csv-loading" style="margin-top:10px; color:#888; font-size:1.05em;"></div>
              <div style="margin-top:18px; color:#888; font-size:1.05em;">Each combination: 5 unique numbers (1-69).</div>
            </div>
          </section>
          <!-- Section 2: Create Combination from 2 Duos (Enhanced) -->
          <section class="generator-section">
            <div class="generator-panel" id="duo-builder-panel" style="background: linear-gradient(135deg, #f8faff 0%, #f0f7ff 100%); border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05);">
              <h2 style="color: #2c3e50; font-size: 1.3em; margin: 0 0 18px 0; padding-bottom: 10px; border-bottom: 2px solid #e0e6ed; display: flex; align-items: center;">
                <i class="fas fa-random" style="margin-right: 10px; color: #3498db;"></i>
                2. Create Combination from 2 Duos
              </h2>
              
              <div class="search-container" style="margin-bottom: 20px;">
                <div style="position: relative; margin-bottom: 15px;">
                  <label for="duo1-select" class="search-label">Select Duo 1:</label>
                  <div class="custom-select" style="position: relative;">
                    <select id="duo1-select" class="enhanced-select" style="width: 100%; padding: 12px 40px 12px 15px; font-size: 1.1em; font-weight: bold; border: 2px solid #d1d8e0; border-radius: 8px; background-color: white; appearance: none; -webkit-appearance: none; -moz-appearance: none; cursor: pointer; transition: all 0.2s ease;" onfocus="this.style.borderColor='#3498db'; this.style.boxShadow='0 0 0 3px rgba(52, 152, 219, 0.2)';" onblur="this.style.borderColor='#d1d8e0'; this.style.boxShadow='none';">
                      <option value="">Search or select a duo...</option>
                    </select>
                    <div class="select-arrow" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); pointer-events: none; color: #7f8c8d;">
                      <i class="fas fa-chevron-down"></i>
                    </div>
                  </div>
                </div>
                
                <div style="position: relative; margin-bottom: 20px;">
                  <label for="duo2-select" class="search-label">Select Duo 2:</label>
                  <div class="custom-select" style="position: relative;">
                    <select id="duo2-select" class="enhanced-select" style="width: 100%; padding: 12px 40px 12px 15px; font-size: 1.1em; font-weight: bold; border: 2px solid #d1d8e0; border-radius: 8px; background-color: white; appearance: none; -webkit-appearance: none; -moz-appearance: none; cursor: pointer; transition: all 0.2s ease;" onfocus="this.style.borderColor='#3498db'; this.style.boxShadow='0 0 0 3px rgba(52, 152, 219, 0.2)';" onblur="this.style.borderColor='#d1d8e0'; this.style.boxShadow='none';">
                      <option value="">Search or select a duo...</option>
                    </select>
                    <div class="select-arrow" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); pointer-events: none; color: #7f8c8d;">
                      <i class="fas fa-chevron-down"></i>
                    </div>
                  </div>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 5px;">
                  <button id="build-duo-combo-btn" class="action-btn" style="flex: 1; background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);" disabled>
                    <i class="fas fa-magic"></i> Generate Combo
                  </button>
                  <button id="clear-duo-selection-btn" class="action-btn" style="flex: 0 0 auto; background: #e74c3c; color: white;" title="Clear selection">
                    <i class="fas fa-times"></i> Clear
                  </button>
                </div>
              </div>
              
              <div id="built-duo-combo-result" style="margin-top: 15px; padding: 15px; background: white; border-radius: 8px; border: 1px solid #e0e6ed; min-height: 60px; display: flex; align-items: center; justify-content: center; font-size: 1.1em; color: #7f8c8d;">
                Your generated combinations will appear here
              </div>
            </div>
          </section>
          
          <!-- Section 3: Create Combination from 1 Duo and 1 Trio (Enhanced) -->
          <section class="generator-section">
            <div class="generator-panel" id="combo-builder-panel" style="background: linear-gradient(135deg, #f8faff 0%, #f0f7ff 100%); border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05);">
              <h2 style="color: #2c3e50; font-size: 1.3em; margin: 0 0 18px 0; padding-bottom: 10px; border-bottom: 2px solid #e0e6ed; display: flex; align-items: center;">
                <i class="fas fa-random" style="margin-right: 10px; color: #9b59b6;"></i>
                3. Create Combination from Duo + Trio
              </h2>
              
              <div class="search-container" style="margin-bottom: 20px;">
                <div style="position: relative; margin-bottom: 15px;">
                  <label for="combo-duo-select" class="search-label">Select Duo:</label>
                  <div class="custom-select" style="position: relative;">
                    <select id="combo-duo-select" class="enhanced-select" style="width: 100%; padding: 12px 40px 12px 15px; font-size: 1.1em; font-weight: bold; border: 2px solid #d1d8e0; border-radius: 8px; background-color: white; appearance: none; -webkit-appearance: none; -moz-appearance: none; cursor: pointer; transition: all 0.2s ease;" onfocus="this.style.borderColor='#9b59b6'; this.style.boxShadow='0 0 0 3px rgba(155, 89, 182, 0.2)';" onblur="this.style.borderColor='#d1d8e0'; this.style.boxShadow='none';">
                      <option value="">Search or select a duo...</option>
                    </select>
                    <div class="select-arrow" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); pointer-events: none; color: #7f8c8d;">
                      <i class="fas fa-chevron-down"></i>
                    </div>
                  </div>
                </div>
                
                <div style="position: relative; margin-bottom: 20px;">
                  <label for="combo-trio-select" class="search-label">Select Trio:</label>
                  <div class="custom-select" style="position: relative;">
                    <select id="combo-trio-select" class="enhanced-select" style="width: 100%; padding: 12px 40px 12px 15px; font-size: 1.1em; font-weight: bold; border: 2px solid #d1d8e0; border-radius: 8px; background-color: white; appearance: none; -webkit-appearance: none; -moz-appearance: none; cursor: pointer; transition: all 0.2s ease;" onfocus="this.style.borderColor='#9b59b6'; this.style.boxShadow='0 0 0 3px rgba(155, 89, 182, 0.2)';" onblur="this.style.borderColor='#d1d8e0'; this.style.boxShadow='none';">
                      <option value="">Search or select a trio...</option>
                    </select>
                    <div class="select-arrow" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); pointer-events: none; color: #7f8c8d;">
                      <i class="fas fa-chevron-down"></i>
                    </div>
                  </div>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 5px;">
                  <button id="build-combo-btn" class="action-btn" style="flex: 1; background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);" disabled>
                    <i class="fas fa-magic"></i> Generate Combo
                  </button>
                  <button id="clear-combo-selection-btn" class="action-btn" style="flex: 0 0 auto; background: #e74c3c; color: white;" title="Clear selection">
                    <i class="fas fa-times"></i> Clear
                  </button>
                </div>
              </div>
              
              <div id="built-combo-result" style="margin-top: 15px; padding: 15px; background: white; border-radius: 8px; border: 1px solid #e0e6ed; min-height: 60px; display: flex; align-items: center; justify-content: center; font-size: 1.1em; color: #7f8c8d;">
                Your generated combinations will appear here
              </div>
            </div>
          </section>
        </div>

        <a href="index.html" class="back-link">&larr; Back to Main</a>
      </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
    let historicalCombos = [];
    let allMainDraws = [];
    // Store the actual numbers array for trio counting
    let allMainDrawsNumbers = [];
    const csvLoading = document.getElementById('csv-loading');
    // Load and parse the CSV file
    csvLoading.textContent = 'Loading historical Powerball data...';
    fetch('powerball.csv')
        .then(response => response.text())
        .then(rawCsv => {
            // Clean the CSV: remove all quotes, trim spaces, standardize header
            let lines = rawCsv.split('\n').map(line => line.replace(/"/g, '').trim());
            if (lines[0].toLowerCase().includes('date') && lines[0].toLowerCase().includes('winning numbers')) {
                lines[0] = 'Date,Winning Numbers,Powerball,PowerPlay';
            }
            lines = lines.map(line => line.split(',').map(f => f.trim()).join(','));
            const cleanedCsv = lines.join('\n');
            Papa.parse(cleanedCsv, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    const data = results.data;
                    // Extract all main draw combinations
                    historicalCombos = [];
                    allMainDraws = [];
                    for (let i = 0; i < data.length; i++) {
                        const row = data[i];
                        const dateStr = (row.Date || '').trim();
                        const parts = dateStr.split('/');
                        const year = parts.length === 3 ? parseInt(parts[2], 10) : 0;
                        // Main draw row
                        if (row.Date && year >= 2016 && row['Winning Numbers'] && row['Winning Numbers'].toLowerCase().includes('powerball')) {
                            let winNumbers = row['Winning Numbers'].replace(/®/g, '').replace(/Powerball.*Numbers\s*/i, '').trim();
                            let mainArr = winNumbers.split(' - ').map(x => parseInt(x.trim(), 10)).filter(n => n >= 1 && n <= 69);
                            if (mainArr.length === 5) {
                                let drawDate = null;
                                let formattedDate = 'Unknown date';
                                
                                try {
                                    if (row.Date) {
                                        // Try parsing the date from various formats
                                        const dateStr = row.Date.trim();
                                        const dateParts = dateStr.split(/[\/\s-]/);
                                        
                                        if (dateParts.length >= 3) {
                                            // Handle MM/DD/YYYY or similar formats
                                            const month = parseInt(dateParts[0], 10) - 1; // Months are 0-based
                                            const day = parseInt(dateParts[1], 10);
                                            const year = parseInt(dateParts[2], 10);
                                            
                                            if (!isNaN(month) && !isNaN(day) && !isNaN(year)) {
                                                drawDate = new Date(year, month, day);
                                                if (!isNaN(drawDate.getTime())) {
                                                    formattedDate = drawDate.toLocaleDateString();
                                                }
                                            }
                                        }
                                    }
                                } catch (e) {
                                    console.error('Error parsing date:', e, row.Date);
                                }
                                
                                historicalCombos.push({
                                    combo: mainArr.slice().sort((a,b)=>a-b).join('-')
                                });
                                allMainDraws.push({ 
                                    numbers: mainArr,
                                    year: drawDate ? drawDate.getFullYear() : 0,
                                    date: drawDate,
                                    formattedDate: formattedDate
                                });
                                allMainDrawsNumbers.push(mainArr);
                            }
                            // Check next row for Double Play
                            if (i + 1 < data.length) {
                                const nextRow = data[i + 1];
                                if (!nextRow.Date && nextRow['Winning Numbers'] && nextRow['Winning Numbers'].toLowerCase().includes('double play')) {
                                    let doubleNumbers = nextRow['Winning Numbers'].replace(/®/g, '').replace(/Double Play.*Numbers\s*/i, '').trim();
                                    let doubleArr = doubleNumbers.split(' - ').map(x => parseInt(x.trim(), 10)).filter(n => n >= 1 && n <= 69);
                                    if (doubleArr.length === 5) {
                                        let drawDate = null;
                                        let formattedDate = 'Unknown date';
                                        
                                        try {
                                            if (row.Date) {  // Use the date from the main draw row
                                                const dateStr = row.Date.trim();
                                                const dateParts = dateStr.split(/[\/\s-]/);
                                                
                                                if (dateParts.length >= 3) {
                                                    const month = parseInt(dateParts[0], 10) - 1;
                                                    const day = parseInt(dateParts[1], 10);
                                                    const year = parseInt(dateParts[2], 10);
                                                    
                                                    if (!isNaN(month) && !isNaN(day) && !isNaN(year)) {
                                                        drawDate = new Date(year, month, day);
                                                        if (!isNaN(drawDate.getTime())) {
                                                            formattedDate = drawDate.toLocaleDateString() + ' (Double Play)';
                                                        }
                                                    }
                                                }
                                            }
                                        } catch (e) {
                                            console.error('Error parsing date for double play:', e, row.Date);
                                        }
                                        
                                        allMainDraws.push({ 
                                            numbers: doubleArr,
                                            year: drawDate ? drawDate.getFullYear() : 0,
                                            date: drawDate,
                                            formattedDate: formattedDate
                                        });
                                        allMainDrawsNumbers.push(doubleArr);
                                    }
                                }
                            }
                        }
                    }
                    csvLoading.textContent = '';
                    // Now analyze frequent sets
                    // Use requestIdleCallback to run non-critical tasks when the browser is idle
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(() => {
                            analyzeFrequentSets();
                            countTrioOccurrences();
                        }, { timeout: 2000 }); // Fallback if idle doesn't happen within 2s
                    } else {
                        // Fallback for browsers that don't support requestIdleCallback
                        setTimeout(() => {
                            analyzeFrequentSets();
                            countTrioOccurrences();
                        }, 0);
                    }
                },
                error: function(error) {
                    console.error('Error parsing CSV:', error);
                }
            });
        });
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function generateUniqueNumbers(count, min, max, exclude=[]) {
        const nums = [];
        while (nums.length < count) {
            const num = Math.floor(Math.random() * (max - min + 1)) + min;
            if (!nums.includes(num) && !exclude.includes(num)) {
                nums.push(num);
            }
        }
        return nums.sort((a, b) => a - b);
    }

    function generateCombination() {
        const mainNumbers = generateUniqueNumbers(5, 1, 69);
        return { mainNumbers };
    }
    function countComboInHistory(whiteBalls) {
        const key = whiteBalls.slice().sort((a,b)=>a-b).join('-');
        return historicalCombos.filter(h => h.combo === key).length;
    }
    
    // Function to check if at least 4 numbers from a combination have appeared before and get history
    function getComboHistory(whiteBalls) {
        if (!whiteBalls || !Array.isArray(whiteBalls) || whiteBalls.length === 0) {
            return { appeared: false };
        }
        
        const sortedBalls = [...whiteBalls].sort((a, b) => a - b);
        const matches = [];
        
        // Check for partial matches (at least 4 numbers)
        allMainDraws.forEach(draw => {
            if (!draw || !draw.numbers || !Array.isArray(draw.numbers)) return;
            
            const drawNumbers = [...draw.numbers].sort((a, b) => a - b);
            const commonNumbers = sortedBalls.filter(num => drawNumbers.includes(num));
            
            if (commonNumbers.length >= 4) {
                // Ensure we have a valid formatted date
                let displayDate = 'Unknown date';
                try {
                    if (draw.formattedDate) {
                        displayDate = draw.formattedDate;
                    } else if (draw.date) {
                        if (draw.date instanceof Date) {
                            displayDate = draw.date.toLocaleDateString();
                        } else if (typeof draw.date === 'string') {
                            displayDate = draw.date;
                        }
                    }
                } catch (e) {
                    console.error('Error formatting date:', e);
                }
                
                matches.push({
                    date: draw.date,
                    formattedDate: displayDate,
                    matchedNumbers: commonNumbers,
                    powerball: draw.powerball || null
                });
            }
        });
        
        if (matches.length === 0) {
            return { appeared: false };
        }
        
        // Sort by most recent first (if we have valid dates)
        try {
            matches.sort((a, b) => {
                const dateA = a.date instanceof Date ? a.date : new Date(a.formattedDate);
                const dateB = b.date instanceof Date ? b.date : new Date(b.formattedDate);
                
                if (isNaN(dateA)) return 1;  // Invalid dates go to the end
                if (isNaN(dateB)) return -1;  // Valid dates come first
                
                return dateB - dateA;  // Sort descending (newest first)
            });
        } catch (e) {
            console.error('Error sorting dates:', e);
        }
        
        // Prepare the dates for display
        const displayDates = matches
            .map(m => m.formattedDate)
            .filter(d => d && d !== 'Unknown date')
            .slice(0, 2); // Only show the first two dates
        
        return {
            appeared: true,
            count: matches.length,
            dates: displayDates,
            powerballs: [...new Set(matches
                .filter(m => m.powerball)
                .map(m => m.powerball)
                .filter(Boolean))],
            matchedNumbers: matches[0]?.matchedNumbers || [],
            isPartialMatch: true
        };
    }
    function generateFromFrequentTrios() {
        if (!window.sortedTriplets || window.sortedTriplets.length === 0) {
            alert('Loading frequent trios data... Please try again in a moment.');
            return [1, 2, 3, 4, 5]; // Return a default set for testing
        }
        
        try {
            // Get top 10 most frequent trios
            const topTrios = window.sortedTriplets.slice(0, 10);
            
            if (topTrios.length === 0) {
                return [1, 2, 3, 4, 5]; // Return a default set for testing
            }
            
            const selectedTrio = topTrios[Math.floor(Math.random() * topTrios.length)];
            
            if (!selectedTrio || !selectedTrio[0]) {
                return [1, 2, 3, 4, 5]; // Return a default set for testing
            }
            
            const [n1, n2, n3] = selectedTrio[0].split('-').map(Number);
            
            // Generate 2 more unique numbers not in the trio
            const exclude = [n1, n2, n3];
            const additionalNumbers = generateUniqueNumbers(2, 1, 69, exclude);
            
            const combination = [...[n1, n2, n3], ...additionalNumbers].sort((a, b) => a - b);
            return {
                combination: combination,
                basedOnTrio: `${n1}-${n2}-${n3}`
            };
        } catch (error) {
            return [1, 2, 3, 4, 5]; // Return a default set if there's an error
        }
    }
    
    // Track used trios for round-robin and prevent duplicates
    let usedTrioIndices = new Set();
    let lastUsedTrioIndex = -1;
    let usedTrioCombinations = new Set(); // Track full trio combinations that have been used
    
    function generateFromOverlappingTrios() {
        // Generate a simple combination if no trios are available
        const generateSimpleCombination = () => {
            const nums = [];
            while (nums.length < 5) {
                const num = Math.floor(Math.random() * 69) + 1;
                if (!nums.includes(num)) nums.push(num);
            }
            return {
                combination: nums.sort((a, b) => a - b),
                basedOnTrio: 'Random (fallback)',
                isOverlap: false
            };
        };
        
        if (!window.sortedTriplets || window.sortedTriplets.length < 2) {
            return generateSimpleCombination();
        }
        
        try {
            // Filter trios that appear more than 3 times
            const frequentTrios = window.sortedTriplets.filter(t => t[1] > 3);
            // Also include some less frequent trios (1-3 occurrences)
            const additionalTrios = window.sortedTriplets.filter(t => t[1] <= 3 && t[1] >= 1);
            
            // Combine both lists, with frequent trios first
            const validTrios = [...frequentTrios, ...additionalTrios];
            
            if (validTrios.length < 2) {
                return generateSimpleCombination();
            }
            
            // Strategy 1: Find one full trio that shares one or two numbers with another trio
            let selectedTrios = [];
            let commonNumbers = [];
            const maxAttempts = 200;
            let attempts = 0;
            let foundMatch = false;
            
            while (attempts < maxAttempts && !foundMatch) {
                // Pick a random trio that hasn't been used recently
                let baseTrioIndex;
                do {
                    baseTrioIndex = Math.floor(Math.random() * validTrios.length);
                } while (usedTrioIndices.has(baseTrioIndex) && attempts++ < maxAttempts);
                
                if (attempts >= maxAttempts) break;
                
                const baseTrio = validTrios[baseTrioIndex];
                const baseNums = baseTrio[0].split('-').map(Number);
                
                // Find another trio that shares one or two numbers with the base trio
                for (let i = 0; i < validTrios.length; i++) {
                    if (i === baseTrioIndex) continue;
                    
                    const otherTrio = validTrios[i];
                    const otherNums = otherTrio[0].split('-').map(Number);
                    
                    // Find common numbers
                    const common = baseNums.filter(num => otherNums.includes(num));
                    
                    // If they share one or two numbers
                    if (common.length === 1 || common.length === 2) {
                        // Use the full base trio and the other two numbers from the other trio
                        const otherTwoNums = otherNums.filter(num => !baseNums.includes(num));
                        // Ensure we use all base numbers plus additional unique numbers
                        const combination = [...new Set([...baseNums, ...otherTwoNums])].slice(0, 5);
                        
                        // Make sure all base numbers are included
                        const missingBaseNums = baseNums.filter(num => !combination.includes(num));
                        if (missingBaseNums.length > 0) {
                            // Replace some numbers to include missing base numbers
                            combination.splice(-missingBaseNums.length, missingBaseNums.length, ...missingBaseNums);
                        }
                        
                        // Mark this trio as used
                        usedTrioIndices.add(baseTrioIndex);
                        lastUsedTrioIndex = baseTrioIndex;
                        
                        const freq1 = baseTrio[1];
                        // Use the other trio's full numbers and frequency
                        const freq2 = otherTrio[1];
                        return {
                            combination: [...combination].sort((a, b) => a - b),
                            basedOnTrio: `${baseTrio[0]} (${freq1}x) & ${otherTrio[0]} (${freq2}x)`,
                            isOverlap: true
                        };
                    }
                }
                
                attempts++;
            }
            
            // Strategy 2: Find one trio that shares numbers with two other trios
            attempts = 0;
            while (attempts < maxAttempts / 2) {
                // Find a trio that shares numbers with two other trios
                const baseTrioIndex = getNextTrioIndex(validTrios, usedTrioIndices, lastUsedTrioIndex);
                if (baseTrioIndex === -1) break;
                
                const baseTrio = validTrios[baseTrioIndex];
                const baseNums = baseTrio[0].split('-').map(Number);
                
                // Find two other trios that share 1 or 2 numbers with the base trio
                const commonTrios = [];
                
                for (let i = 0; i < validTrios.length; i++) {
                    if (i === baseTrioIndex) continue;
                    
                    const otherTrio = validTrios[i];
                    const otherNums = otherTrio[0].split('-').map(Number);
                    const common = baseNums.filter(num => otherNums.includes(num));
                    
                    // Accept trios that share 1 or 2 numbers
                    if (common.length === 1 || common.length === 2) {
                        commonTrios.push({ trio: otherTrio, common });
                        if (commonTrios.length >= 2) break;
                    }
                }
                
                if (commonTrios.length >= 2) {
                    const [trio1, trio2] = commonTrios;
                    const nums1 = trio1.trio[0].split('-').map(Number);
                    const nums2 = trio2.trio[0].split('-').map(Number);
                    
                    // Get all unique numbers from the three trios
                    const allNums = [...new Set([...baseNums, ...nums1, ...nums2])];
                    
                    if (allNums.length <= 5) {
                        // Mark this trio as used
                        usedTrioIndices.add(baseTrioIndex);
                        lastUsedTrioIndex = baseTrioIndex;
                        
                        const freq1 = baseTrio[1];
                        const freq2 = trio1.trio[1];
                        const freq3 = trio2.trio[1];
                        
                        return {
                            combination: allNums.sort((a, b) => a - b),
                            basedOnTrio: `${baseTrio[0]} (${freq1}x) & ${trio1.trio[0]} (${freq2}x) & ${trio2.trio[0]} (${freq3}x)`,
                            isOverlap: true
                        };
                    }
                }
                
                attempts++;
            }
            
            // Fallback: If no good matches found, use any two trios with one common number
            // First, try to find a combination we haven't used before
            const maxTries = Math.min(validTrios.length, 20);
            const triedIndices = new Set();
            
            for (let attempt = 0; attempt < maxTries; attempt++) {
                // Find a random trio we haven't tried yet for this attempt
                let i;
                do {
                    i = Math.floor(Math.random() * validTrios.length);
                } while (triedIndices.has(i) && triedIndices.size < maxTries);
                
                if (triedIndices.has(i)) continue;
                triedIndices.add(i);
                
                const nums1 = validTrios[i][0].split('-').map(Number);
                const trio1Key = nums1.sort((a, b) => a - b).join('-');
                
                for (let j = 0; j < Math.min(validTrios.length, 20); j++) {
                    if (i === j) continue;
                    
                    const nums2 = validTrios[j][0].split('-').map(Number);
                    const trio2Key = nums2.sort((a, b) => a - b).join('-');
                    
                    // Create a unique key for this trio pair
                    const comboKey = [trio1Key, trio2Key].sort().join('|');
                    
                    // Skip if we've already used this combination
                    if (usedTrioCombinations.has(comboKey)) {
                        continue;
                    }
                    
                    const common = nums1.filter(num => nums2.includes(num));
                    
                    if (common.length > 0) {
                        // Combine numbers from both trios and ensure uniqueness
                        const combined = [...new Set([...nums1, ...nums2])].slice(0, 5);
                        
                        // If we don't have enough numbers, fill with random ones
                        while (combined.length < 5) {
                            const num = Math.floor(Math.random() * 69) + 1;
                            if (!combined.includes(num)) {
                                combined.push(num);
                            }
                        }
                        
                        // Mark this trio combination as used
                        usedTrioCombinations.add(comboKey);
                        
                        // Mark the trios as used for round-robin
                        usedTrioIndices.add(i);
                        usedTrioIndices.add(j);
                        lastUsedTrioIndex = j;
                        
                        return {
                            combination: combined.sort((a, b) => a - b),
                            basedOnTrio: `Combined ${validTrios[i][0]} (${validTrios[i][1]}x) & ${validTrios[j][0]} (${validTrios[j][1]}x)`,
                            isOverlap: true
                        };
                    }
                }
            }
            
            // Final fallback: Generate a completely random combination
            return generateSimpleCombination();
        } catch (error) {
            // Fallback to regular trio generation on error
            return generateFromFrequentTrios();
        }
    }
    
    function renderCombinations(n, useFrequentTrios = false, useOverlappingTrios = false, combo = null) {
        // Ensure n is a valid number
        const count = parseInt(n, 10);
        if (isNaN(count) || count <= 0) {
            return;
        }
        
        const container = document.getElementById('generated-table');
        if (!container) {
            return;
        }
        
        // Ensure container is visible and cleared
        container.style.display = 'block';
        container.style.visibility = 'visible';
        container.style.opacity = '1';
        container.innerHTML = '';
        
        // Create table element
        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.borderCollapse = 'separate';
        table.style.borderSpacing = '0 8px';
        table.style.margin = '0';
        table.style.tableLayout = 'fixed';
        
        // Create table header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headerRow.style.backgroundColor = '#f8f9fa';
        
        // Always create the Numbers header first
        const th2 = document.createElement('th');
        th2.textContent = 'Numbers';
        th2.style.textAlign = 'left';
        th2.style.padding = '12px 8px';
        th2.style.border = 'none';
        
        // Only add border radius if there's no trio info column
        if (!useFrequentTrios && !useOverlappingTrios) {
            th2.style.borderRadius = '0 8px 8px 0';
        } else {
            th2.style.borderRadius = '8px 0 0 8px';
        }
        headerRow.appendChild(th2);
        
        if (useFrequentTrios || useOverlappingTrios) {
            const th3 = document.createElement('th');
            th3.textContent = 'Based On Trio';
            th3.style.textAlign = 'left';
            th3.style.padding = '12px 8px';
            th3.style.border = 'none';
            th3.style.borderRadius = '0 8px 8px 0';
            headerRow.appendChild(th3);
        }
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Create table body
        const tbody = document.createElement('tbody');

        for (let i = 0; i < count; i++) {
            try {
                // Create combination based on frequent or overlapping trios
                let mainNumbers, basedOnTrio = '';
                
                if (useFrequentTrios || useOverlappingTrios) {
                    const result = useOverlappingTrios 
                        ? generateFromOverlappingTrios() 
                        : generateFromFrequentTrios();
                    
                    if (result && result.combination) {
                        mainNumbers = result.combination;
                        basedOnTrio = result.basedOnTrio || '';
                    } else {
                        mainNumbers = generateCombination().mainNumbers;
                    }
                } else {
                    mainNumbers = generateCombination().mainNumbers;
                }

                const comboCard = document.createElement('div');
                comboCard.className = 'combo-card';
                // Only set these attributes if combo object exists
                if (combo) {
                    comboCard.setAttribute('data-pattern', combo.pattern || '0');
                    comboCard.setAttribute('data-trio', combo.basedOnTrio || 'Overlapping Trios');
                }
                comboCard.style.border = '1px solid #e0e0e0';
                comboCard.style.borderRadius = '8px';
                comboCard.style.padding = '15px';
                comboCard.style.marginBottom = '15px';
                comboCard.style.background = '#fff';
                comboCard.style.boxShadow = '0 2px 8px rgba(0,0,0,0.05)';
                comboCard.style.position = 'relative';

                const tr = document.createElement('tr');
                tr.style.display = 'table-row';
                
                // Add numbers cell
                const td2 = document.createElement('td');
                td2.textContent = mainNumbers.join(' - ');
                td2.style.padding = '12px 8px';
                td2.style.fontWeight = 'bold';
                td2.style.color = '#2c3e50';
                td2.style.border = 'none';
                td2.style.whiteSpace = 'nowrap';  // Prevent line breaks in numbers
                
                if (useFrequentTrios || useOverlappingTrios) {
                    td2.style.borderRadius = '8px 0 0 8px';  // Rounded left corners when there's a trio info column
                } else {
                    td2.style.borderRadius = '8px';  // Rounded corners when it's the only column
                }
                tr.appendChild(td2);
                
                // Add trio info if needed
                if (useFrequentTrios || useOverlappingTrios) {
                    const td3 = document.createElement('td');
                    td3.textContent = basedOnTrio;
                    td3.style.padding = '12px 8px';
                    td3.style.color = '#9b59b6';
                    td3.style.fontWeight = '500';
                    td3.style.border = 'none';
                    td3.style.borderRadius = '0 8px 8px 0';
                    tr.appendChild(td3);
                }
                
                tbody.appendChild(tr);
            } catch (error) {
                console.error(`Error generating combination ${i+1}:`, error);
            }
        }
        
        table.appendChild(tbody);
        
        // Create a wrapper div for better control
        const tableWrapper = document.createElement('div');
        tableWrapper.style.overflowX = 'auto';
        tableWrapper.style.width = '100%';
        tableWrapper.appendChild(table);
        
        // Clear and append the table
        container.innerHTML = '';
        container.appendChild(tableWrapper);
        
        // Force a reflow to ensure the table is rendered
        void container.offsetHeight;
    }
    
    // Handle generate from two duos button
    document.getElementById('build-duo-combo-btn').addEventListener('click', function() {
      const duo1Key = document.getElementById('duo1-select').value;
      const duo2Key = document.getElementById('duo2-select').value;
      
      if (!duo1Key || !duo2Key) return;
      
      const combination = generateFromTwoDuos(duo1Key, duo2Key);
      const resultDiv = document.getElementById('built-duo-combo-result');
      
      // Format the result with styling and bolder numbers
      resultDiv.innerHTML = `
        <div class="result-container">
          <div class="result-title">
            <i class="fas fa-star"></i>
            <span style="font-weight: 700; font-size: 1.1em;">Generated Combination</span>
          </div>
          <div style="margin: 15px 0; display: flex; flex-wrap: wrap; gap: 5px; justify-content: center;">
            ${formatCombination(combination)}
          </div>
          <div style="font-size: 0.9em; color: #7f8c8d; margin-top: 15px; padding-top: 10px; border-top: 1px solid #eee;">
            <i class="fas fa-info-circle"></i> This combination was generated from the selected duos.
          </div>
        </div>
      `;
    });
    
    // Handle generate from duo + trio button
    document.getElementById('build-combo-btn').addEventListener('click', function() {
      const duoKey = document.getElementById('combo-duo-select').value;
      const trioKey = document.getElementById('combo-trio-select').value;
      
      if (!duoKey || !trioKey) return;
      
      const combination = generateFromDuoAndTrio(duoKey, trioKey);
      const resultDiv = document.getElementById('built-combo-result');
      
      // Get the selected duo and trio for display
      const duo = duoKey.split(':').map(n => formatNumber(parseInt(n))).join(' - ');
      const trio = trioKey.split(':').map(n => formatNumber(parseInt(n))).join(' - ');
      
      // Format the result with styling and bolder numbers
      resultDiv.innerHTML = `
        <div class="result-container">
          <div class="result-title">
            <i class="fas fa-star"></i>
            <span style="font-weight: 700; font-size: 1.1em;">Generated Combination</span>
          </div>
          <div style="margin: 15px 0; display: flex; flex-wrap: wrap; gap: 5px;justify-content: center;">
            ${formatCombination(combination)}
          </div>
          <div style="font-size: 0.95em; color: #7f8c8d; margin-top: 15px; padding-top: 10px; border-top: 1px solid #eee;">
            <div style="margin-bottom: 6px;"><i class="fas fa-random"></i> <strong style="font-weight: 700;">Source Duo:</strong> 
              <span style="font-weight: 700; color: #2c3e50;">${duo}</span>
            </div>
            <div><i class="fas fa-random"></i> <strong style="font-weight: 700;">Source Trio:</strong> 
              <span style="font-weight: 700; color: #2c3e50;">${trio}</span>
            </div>
          </div>
        </div>
      `;
    });
    
    // Handle regular number generation buttons - number-based generation removed
    
    // Handle overlapping trios button
    document.getElementById('generate-from-overlapping-trios').addEventListener('click', function() {
        // Create a dummy combo object for the renderCombinations function
        const combo = {
            pattern: 0, // Default pattern
            basedOnTrio: 'Overlapping Trios'
        };
        renderCombinations(5, false, true, combo);
    });

    // Enhanced trio generator function using overlapping trios
    // Track used advanced trios for round-robin
let usedAdvancedTrios = new Set();
let advancedTrioIndex = 0;

// Advanced trio generator function with different patterns
function generateAdvancedTrioCombinations() {
    const combinations = [];
    const maxAttempts = 1000;
    let attempts = 0;
    
    // Generate 5 combinations with different patterns
    while (combinations.length < 5 && attempts < maxAttempts) {
        attempts++;
        
        // Get overlapping trios from historical data
        let overlappingResult;
        try {
            overlappingResult = generateFromOverlappingTrios();
            if (!overlappingResult || !overlappingResult.combination) {
                console.error('Failed to generate overlapping trios');
                continue;
            }
        } catch (error) {
            console.error('Error in generateFromOverlappingTrios:', error);
            continue;
        }
        
        // Get the base combination from overlapping trios
        const baseCombination = [...overlappingResult.combination];
        const trioKey = baseCombination.slice(0, 3).sort((a, b) => a - b).join(',');
        
        // Skip if we've used this trio before
        if (usedAdvancedTrios.has(trioKey)) continue;
        
        // Determine pattern based on combination index
        const pattern = combinations.length % 5; // 5 different patterns
        
        // Adjust numbers to match the desired pattern
        let adjustedCombination = [...baseCombination];
        
        // Advanced pattern matching
        switch (pattern) {
            case 0: // Alternating high/low
                adjustedCombination = adjustedCombination.map((num, i) => {
                    if (i % 2 === 0) return Math.min(35, num); // Lower numbers for even indices
                    return Math.max(36, num); // Higher numbers for odd indices
                });
                break;
                
            case 1: // All numbers in same decade (10s, 20s, etc.)
                const decade = Math.floor(Math.random() * 6) * 10; // 0, 10, 20, 30, 40, 50
                adjustedCombination = adjustedCombination.map(() => {
                    return Math.max(1, Math.min(69, decade + Math.floor(Math.random() * 9) + 1));
                });
                break;
                
            case 2: // Consecutive numbers
                const start = Math.max(1, Math.min(65, adjustedCombination[0]));
                adjustedCombination = [start, start + 1, start + 2, start + 3, start + 4];
                
                // Validate that the trios match the pattern
                const trio1Count = trio1Info.count || 0;
                const trio2Count = trio2Info.count || 0;
                
                // Get the expected min and max from the pattern name (e.g., '1x-3x' -> min=1, max=3)
                const [minExpected, maxExpected] = pattern.name.split('-').map(s => parseInt(s));
                
                // Check if the trios match the pattern
                const validCounts = (
                    (trio1Count >= minExpected && trio1Count <= maxExpected) &&
                    (trio2Count >= minExpected && trio2Count <= maxExpected) &&
                    (trio1Count <= maxExpected && trio2Count <= maxExpected)
                );
                
                if (!validCounts) {
                    console.log(`Skipping invalid pattern match: ${trio1Count}x-${trio2Count}x for pattern ${pattern.name}`);
                    continue;
                }
                
                // Ensure we have a mix of odd/even and high/low
                const hasOdd = adjustedCombination.some(n => n % 2 === 1);
                const hasEven = adjustedCombination.some(n => n % 2 === 0);
                const hasLow = adjustedCombination.some(n => n <= 39);
                const hasHigh = adjustedCombination.some(n => n >= 40);
                
                if (!hasOdd || !hasEven || !hasLow || !hasHigh) {
                    console.log('Skipping combination without a mix of odd/even and high/low numbers');
                    continue;
                }
                break;
                
            case 3: // All odd or all even
                const allEven = Math.random() > 0.5;
                adjustedCombination = adjustedCombination.map(num => {
                    let n = Math.max(1, Math.min(69, num));
                    if (allEven && n % 2 !== 0) return n + 1 <= 69 ? n + 1 : n - 1;
                    if (!allEven && n % 2 === 0) return n + 1 <= 69 ? n + 1 : n - 1;
                    return n;
                });
                break;
                
            case 4: // Fibonacci sequence based
                const fibStart = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89].filter(n => n <= 69);
                const startIdx = Math.floor(Math.random() * (fibStart.length - 5));
                adjustedCombination = fibStart.slice(startIdx, startIdx + 5);
                break;
        }
        
        // Ensure no duplicates and valid range
        const uniqueNums = new Set(adjustedCombination);
        if (uniqueNums.size !== 5) continue;
        if (Math.min(...adjustedCombination) < 1 || Math.max(...adjustedCombination) > 69) continue;
        
        // Get trio occurrence info for display
        const trioForDisplay = adjustedCombination.slice(0, 3).sort((a, b) => a - b);
        const trioOccurrence = getTrioOccurrenceInfo(trioForDisplay);
        
        // Add to combinations
        combinations.push({
            numbers: [...adjustedCombination].sort((a, b) => a - b),
            powerball: getNextPowerball(),
            basedOnTrio: `Trios(${trioForDisplay.join('-')} (${trioOccurrence.text}))`,
            pattern: ['Alternating High/Low', 'Same Decade', 'Consecutive', 
                         combinations[combinations.length-1]?.numbers.every(n => n % 2 === 0) ? 'All Even' : 'All Odd', 
                         'Fibonacci'][pattern]
        });
        
        // Add to used trios for round-robin
        usedAdvancedTrios.add(trioKey);
        advancedTrioIndex++;
        
        // Reset if we've used all trios
        if (advancedTrioIndex >= 100) {
            usedAdvancedTrios.clear();
            advancedTrioIndex = 0;
        }
    }
    
    // Render the combinations with a different style
    renderAdvancedCombinations(combinations);
}

// Render function for advanced combinations
function renderAdvancedCombinations(combinations) {
    const container = document.getElementById('generated-table');
    if (!container) return;
    
    const patternNames = [
        'Alternating High/Low',
        'Same Decade',
        'Consecutive Numbers',
        'All Odd/Even',
        'Fibonacci Sequence'
    ];
    
    let html = '<div class="enhanced-combinations">';
    html += `
    <div style="margin-bottom: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0; color: #2c3e50; font-size: 1.2em;">Advanced Trio Combinations</h3>
            <button id="download-advanced-combinations" class="btn btn-primary" style="background: linear-gradient(90deg, #3498db 0%, #2980b9 100%); border: none; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em; display: flex; align-items: center; gap: 5px;">
                <i class="fas fa-download"></i> Download
            </button>
        </div>
        <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
            <span style="background: #e3f2fd; color: #1976d2; padding: 4px 10px; border-radius: 15px; font-size: 0.85em;">
                <i class="fas fa-magic"></i> Advanced Patterns
            </span>
            <span style="background: #e8f5e9; color: #27ae60; padding: 4px 10px; border-radius: 15px; font-size: 0.85em;">
                <i class="fas fa-sync-alt"></i> Smart Cycling
            </span>
            <span style="background: #fff3e0; color: #f39c12; padding: 4px 10px; border-radius: 15px; font-size: 0.85em;">
                <i class="fas fa-chart-line"></i> Pattern Analysis
            </span>
        </div>
    `;
    
    combinations.forEach((combo, index) => {
        const patternName = combo.patternName || patternNames[combo.pattern] || 'Advanced Pattern';
        const endings = combo.numbers.map(n => n % 10);
        const uniqueEndings = [...new Set(endings)];
        const duplicateEndings = endings.length - uniqueEndings.length > 0;
        
        html += `
        <div class="combo-card" style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); border-left: 4px solid #3498db;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px; align-items: center;">
                <div style="display: flex; gap: 8px; align-items: center;">
                    <span style="font-weight: 600; color: #2c3e50;">#${index + 1}</span>
                    <span style="background: #e3f2fd; color: #1976d2; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; font-weight: 500;">
                        ${patternName}
                    </span>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-bottom: 12px; flex-wrap: wrap;">
                ${combo.numbers.map(num => 
                    `<div style="width: 36px; height: 36px; border-radius: 50%; background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1.1em; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        ${num}
                    </div>`
                ).join('')}
                <div style="width: 36px; height: 36px; border-radius: 50%; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 1.1em; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    ${combo.powerball}
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; font-size: 0.85em; color: #7f8c8d;">
                <span><i class="fas fa-hashtag"></i> Sum: ${combo.numbers.reduce((a, b) => a + b, 0)}</span>
                <span><i class="fas fa-sort-numeric-up"></i> Range: ${Math.max(...combo.numbers) - Math.min(...combo.numbers)}</span>
                <span><i class="fas fa-equals"></i> ${duplicateEndings ? 'Has duplicate endings' : 'All unique endings'}</span>
            </div>
        </div>`;
    });
    
    html += '</div>';
    container.innerHTML = html;
    
    // Add download handler for the new button
    document.getElementById('download-advanced-combinations')?.addEventListener('click', function() {
        const container = document.querySelector('.enhanced-combinations');
        if (!container) return;
        
        const combinations = [];
        const comboElements = container.querySelectorAll('.combo-card');
        
        comboElements.forEach(comboEl => {
            const numbers = Array.from(comboEl.querySelectorAll('div[style*="background: linear-gradient"][style*="border-radius: 50%"]'))
                .filter(el => !el.textContent.includes('PB'))
                .map(ball => parseInt(ball.textContent));
            const powerball = parseInt(comboEl.querySelector('div[style*="background: linear-gradient"][style*="border-radius: 50%"]:last-child')?.textContent || '0');
            const pattern = comboEl.querySelector('span[style*="background: #e3f2fd"]')?.textContent.trim() || 'Advanced';
            
            combinations.push({
                numbers: numbers,
                powerball: powerball,
                pattern: pattern,
                basedOnTrio: ''
            });
        });
        
        if (combinations.length > 0) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `advanced-combinations-${timestamp}.txt`;
            const text = formatCombinationsForDownload(combinations);
            downloadTextAsFile(text, filename);
        } else {
            alert('No combinations to download. Please generate some combinations first.');
        }
    });
}

// Track used patterned trios for round-robin
let usedPatternedTrios = new Set();
let patternedTrioIndex = 0;

// Track used enhanced trios for round-robin
let usedEnhancedTrios = new Set();
let enhancedTrioIndex = 0;

// Store historical Powerball numbers
let historicalPowerballs = [];
let currentPowerballIndex = 0;

// Function to load historical Powerball numbers from CSV
async function loadHistoricalPowerballs() {
    try {
        const response = await fetch('powerball.csv');
        const csvData = await response.text();
        
        // Parse CSV data
        const lines = csvData.split('\n');
        const powerballs = [];
        
        for (const line of lines) {
            // Match Powerball numbers in the format "1 - 2 - 3 - 4 - 5" or "1 2 3 4 5"
            const match = line.match(/Powerball® Numbers\s+([\d\s-]+)","\s*(\d+)/);
            if (match && match[2]) {
                const powerball = parseInt(match[2].trim(), 10);
                if (powerball >= 1 && powerball <= 26) {
                    powerballs.push(powerball);
                }
            }
            
            // Alternative format matching for older data
            const altMatch = line.match(/"\s*(\d+)\s+-\s+\d+\s+-\s+\d+\s+-\s+\d+\s+-\s+\d+\s+","\s*(\d+)/);
            if (altMatch && altMatch[2]) {
                const powerball = parseInt(altMatch[2].trim(), 10);
                if (powerball >= 1 && powerball <= 26) {
                    powerballs.push(powerball);
                }
            }
        }
        
        // If we found any powerballs, use them; otherwise, fall back to a default set
        if (powerballs.length > 0) {
            historicalPowerballs = powerballs;
        } else {
            // Fallback to all possible powerballs if none found in the file
            historicalPowerballs = Array.from({length: 26}, (_, i) => i + 1);
        }
        
        // Shuffle the powerballs to avoid patterns
        historicalPowerballs = historicalPowerballs.sort(() => Math.random() - 0.5);
        
    } catch (error) {
        console.error('Error loading historical powerballs:', error);
        // Fallback to all possible powerballs if there's an error
        historicalPowerballs = Array.from({length: 26}, (_, i) => i + 1);
    }
}

// Function to get the next historical powerball
function getNextPowerball() {
    if (historicalPowerballs.length === 0) {
        // Fallback if no historical data is available
        return Math.floor(Math.random() * 26) + 1;
    }
    
    const powerball = historicalPowerballs[currentPowerballIndex];
    currentPowerballIndex = (currentPowerballIndex + 1) % historicalPowerballs.length;
    return powerball;
}

// Load historical powerballs when the script loads
loadHistoricalPowerballs();

// Track actual trio occurrences from historical data
let trioOccurrenceMap = new Map();

// Initialize trio occurrence counting when the page loads
document.addEventListener('DOMContentLoaded', function() {
    // Wait a short time to ensure all data is loaded
    setTimeout(() => {
        if (allMainDraws.length > 0) {
            console.log('Initializing trio occurrence counting...');
            countTrioOccurrences();
            
            // Also initialize the frequent sets analysis
            if (typeof analyzeFrequentSets === 'function') {
                analyzeFrequentSets();
            }
        }
    }, 1000); // Small delay to ensure everything is loaded
});

// Function to count trio occurrences in historical data
function countTrioOccurrences() {
    console.log('=== Starting trio occurrence counting ===');
    trioOccurrenceMap.clear();
    
    if (!allMainDrawsNumbers || allMainDrawsNumbers.length === 0) {
        console.error('No historical data available for counting trios');
        return;
    }
    
    console.log('Total draws to process:', allMainDrawsNumbers.length);
    
    // First, verify the data and collect all valid numbers
    const allValidNumbers = new Set();
    allMainDrawsNumbers.forEach((numbers, index) => {
        if (!Array.isArray(numbers) || numbers.length !== 5) {
            console.error('Invalid draw at index', index, ':', numbers);
            return;
        }
        numbers.forEach(num => allValidNumbers.add(num));
    });
    
    console.log('Total unique numbers found in all draws:', allValidNumbers.size);
    
    // Count occurrences of each trio in historical data
    allMainDrawsNumbers.forEach((numbers, drawIndex) => {
        if (drawIndex % 100 === 0) {
            console.log(`Processing draw ${drawIndex + 1}/${allMainDrawsNumbers.length}`);
        }
        
        const sortedDraw = [...numbers].sort((a, b) => a - b);
        
        // Generate all possible trios from these 5 numbers (10 total)
        const trios = [
            [sortedDraw[0], sortedDraw[1], sortedDraw[2]],
            [sortedDraw[0], sortedDraw[1], sortedDraw[3]],
            [sortedDraw[0], sortedDraw[1], sortedDraw[4]],
            [sortedDraw[0], sortedDraw[2], sortedDraw[3]],
            [sortedDraw[0], sortedDraw[2], sortedDraw[4]],
            [sortedDraw[0], sortedDraw[3], sortedDraw[4]],
            [sortedDraw[1], sortedDraw[2], sortedDraw[3]],
            [sortedDraw[1], sortedDraw[2], sortedDraw[4]],
            [sortedDraw[1], sortedDraw[3], sortedDraw[4]],
            [sortedDraw[2], sortedDraw[3], sortedDraw[4]]
        ];
        
        if (drawIndex === 0) {
            console.log('First draw numbers:', sortedDraw);
            console.log('Generated trios for first draw:', trios);
        }
        
        // Count each unique trio
        const uniqueTrios = new Set(trios.map(trio => trio.join(',')));
        
        uniqueTrios.forEach(trioKey => {
            const currentCount = trioOccurrenceMap.get(trioKey) || 0;
            trioOccurrenceMap.set(trioKey, currentCount + 1);
        });
    });
    
    console.log('Trio occurrence counting complete. Total unique trios found:', trioOccurrenceMap.size);
    
    // Log some sample data for debugging
    const sampleTrios = Array.from(trioOccurrenceMap.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
    console.log('Top 5 most frequent trios:', sampleTrios);
}

// Track used occurrence patterns
let currentOccurrencePatternIndex = 0;

// Function to get trio occurrence info based on actual historical data
// Function to count duo occurrences in historical data
function countDuoOccurrences(duo) {
    if (!window.duoOccurrenceMap) {
        // Initialize duo occurrence map if it doesn't exist
        window.duoOccurrenceMap = new Map();
        
        // Count all duos in historical data
        allMainDrawsNumbers.forEach(draw => {
            const sortedDraw = [...draw].sort((a, b) => a - b);
            
            // Generate all possible duos from these 5 numbers (10 total)
            for (let i = 0; i < sortedDraw.length; i++) {
                for (let j = i + 1; j < sortedDraw.length; j++) {
                    const duoKey = [sortedDraw[i], sortedDraw[j]].sort((a, b) => a - b).join(',');
                    const currentCount = window.duoOccurrenceMap.get(duoKey) || 0;
                    window.duoOccurrenceMap.set(duoKey, currentCount + 1);
                }
            }
        });
    }
    
    const duoKey = [...duo].sort((a, b) => a - b).join(',');
    return window.duoOccurrenceMap.get(duoKey) || 0;
}

function getTrioOccurrenceInfo(trio) {
    if (!trio || !Array.isArray(trio) || trio.length !== 3) {
        console.error('Invalid trio input:', trio);
        return {
            text: '0x',
            count: 0,
            duoCount: 0,
            numbers: []
        };
    }
    
    // Sort the trio to ensure consistent key generation
    const sortedTrio = [...trio].sort((a, b) => a - b);
    const trioKey = sortedTrio.join(',');
    
    // Get the count from the map - ensure it's a number and not undefined
    const count = Number(trioOccurrenceMap.get(trioKey) || 0);
    
    // Calculate duo occurrences for this trio
    let maxDuoCount = 0;
    const duoCounts = [];
    
    // Check all possible duos in this trio
    for (let i = 0; i < 3; i++) {
        for (let j = i + 1; j < 3; j++) {
            const duo = [sortedTrio[i], sortedTrio[j]];
            const duoCount = countDuoOccurrences(duo);
            duoCounts.push(duoCount);
            if (duoCount > maxDuoCount) {
                maxDuoCount = duoCount;
            }
        }
    }
    
    // Ensure we're not showing higher occurrence counts than the actual trio count
    const adjustedDuoCounts = duoCounts.map(c => Math.min(c, count));
    const adjustedMaxDuoCount = Math.min(maxDuoCount, count);
    
    // Create a more detailed text representation
    let text = '';
    if (count > 0) {
        text = `${count}x`;
        if (adjustedMaxDuoCount > 0) {
            text += ` (Duos: ${adjustedDuoCounts.join('x, ')}x)`;
        }
    }
    
    return {
        text: text,
        count: count,
        duoCount: adjustedMaxDuoCount,
        numbers: sortedTrio,
        duoCounts: adjustedDuoCounts
    };
}

// Patterned trio generator with specific occurrence patterns
function generatePatternedTrioCombinations() {
    // --- ROUND ROBIN HIGH ENDING LOGIC ---
    // Always use a fixed round robin order for each batch
    const fixedHighRanges = [60, 50, 40, 30];
    let rrIndex = 0; // local to this generation
    // Helper to get the next high ending range (cycles through 60,50,40,30)
    function getNextHighEndingRange() {
        const range = fixedHighRanges[rrIndex % fixedHighRanges.length];
        rrIndex++;
        return range;
    }
    // --- END ROUND ROBIN LOGIC ---
    const combinations = [];
    const maxAttempts = 200;
    let attempts = 0;
    
    // Define our occurrence patterns
    const occurrencePatterns = [
        // Trio-Trio patterns
        { name: '1x-1x', type: 'trio-trio', minOccurrences: 1, maxOccurrences: 1 },
        { name: '1x-2x', type: 'trio-trio', minOccurrences: 1, maxOccurrences: 2 },
        { name: '1x-3x', type: 'trio-trio', minOccurrences: 1, maxOccurrences: 3 },
        { name: '2x-2x', type: 'trio-trio', minOccurrences: 2, maxOccurrences: 2 },
        { name: '2x-3x', type: 'trio-trio', minOccurrences: 2, maxOccurrences: 3 },
        { name: '3x-3x', type: 'trio-trio', minOccurrences: 3, maxOccurrences: 3 },
        
        // Trio-Duo patterns
        { name: 'trio(1x)-duo(2x)', type: 'trio-duo', trioOccurrences: 1, duoOccurrences: 2 },
        { name: 'trio(1x)-duo(3x)', type: 'trio-duo', trioOccurrences: 1, duoOccurrences: 3 },
        { name: 'trio(1x)-duo(4x)', type: 'trio-duo', trioOccurrences: 1, duoOccurrences: 4 },
        { name: 'trio(1x)-duo(5x)', type: 'trio-duo', trioOccurrences: 1, duoOccurrences: 5 },
        { name: 'trio(2x)-duo(2x)', type: 'trio-duo', trioOccurrences: 2, duoOccurrences: 2 },
        { name: 'trio(2x)-duo(3x)', type: 'trio-duo', trioOccurrences: 2, duoOccurrences: 3 },
        { name: 'trio(2x)-duo(4x)', type: 'trio-duo', trioOccurrences: 2, duoOccurrences: 4 },
        { name: 'trio(2x)-duo(5x)', type: 'trio-duo', trioOccurrences: 2, duoOccurrences: 5 },
        { name: 'trio(3x)-duo(3x)', type: 'trio-duo', trioOccurrences: 3, duoOccurrences: 3 },
        { name: 'trio(3x)-duo(4x)', type: 'trio-duo', trioOccurrences: 3, duoOccurrences: 4 },
        { name: 'trio(3x)-duo(5x)', type: 'trio-duo', trioOccurrences: 3, duoOccurrences: 5 }
    ];
    
    // Track used trios for round-robin and globally
    if (!window.usedTrioPatterns) {
        window.usedTrioPatterns = new Map();
        window.allUsedTrios = new Set(); // Track all used trios across all patterns
        window.usedTrioCombinations = new Set(); // Track all used trio combinations
        occurrencePatterns.forEach(pattern => {
            window.usedTrioPatterns.set(pattern.name, new Set());
        });
    }
    
    // Reset used trios tracking if we're starting a new generation
    if (window.currentPatternIndex === undefined || window.currentPatternIndex >= occurrencePatterns.length) {
        window.currentPatternIndex = 0;
        window.allUsedTrios.clear();
        window.usedTrioCombinations.clear();
        // Also clear all pattern-specific used trios
        for (const pattern of occurrencePatterns) {
            const usedTrios = window.usedTrioPatterns.get(pattern.name);
            if (usedTrios) usedTrios.clear();
        }
    }
    
    // Track how many times we've generated high number combinations
    if (window.highNumberCounter === undefined) {
        window.highNumberCounter = 0;
    }
    // Generate combinations for each occurrence pattern in round-robin fashion
    while (combinations.length < 5 && attempts < maxAttempts) {
        attempts++;
        
        // Get the current pattern in round-robin fashion
        const pattern = occurrencePatterns[window.currentPatternIndex % occurrencePatterns.length];
        window.currentPatternIndex++;
        
        // Get the set of used trios for this pattern
        const usedTrios = window.usedTrioPatterns.get(pattern.name);
        
        // Find two trios that match the occurrence pattern
        let trio1 = null, trio2 = null;
        let trio1Info = null, trio2Info = null;

        // ---- ROUND ROBIN HIGH ENDING FILTER ----
        const targetHighRange = getNextHighEndingRange();
        function isTrioInTargetRange(trio, requireHigh=false) {
            const max = Math.max(...trio);
            if (requireHigh && targetHighRange === 60) {
                // Require 60-69 for the 60s round (including 60)
                return max >= 60 && max <= 69;
            }
            return max >= targetHighRange && max < targetHighRange + 10;
        }
        // ---- END FILTER ----
        // Try to find a matching pair of trios
        for (let i = 0; i < 30; i++) { // Reduced attempts for better performance
            const result1 = generateFromOverlappingTrios();
            if (!result1 || !result1.combination) continue;
            
            const t1 = result1.combination.slice(0, 3).sort((a, b) => a - b);
            const t1Key = t1.join(',');
            const t1Info = getTrioOccurrenceInfo(t1);
            
            // Quick filter for target range
            if (!isTrioInTargetRange(t1, targetHighRange === 60)) {
                continue;
            }
            
            // Skip if trio1 has been used before or doesn't match the pattern requirements
            if (window.allUsedTrios.has(t1Key)) {
                continue; // Skip if this trio has been used before
            }
            
            if (pattern.type === 'trio-trio' && (t1Info.count < pattern.minOccurrences || t1Info.count === 0)) {
                continue;
            } else if (pattern.type === 'trio-duo' && (t1Info.count !== pattern.trioOccurrences || t1Info.duoCount === 0)) {
                continue;
            }
            
            // Try to find a second trio that forms a valid pair
            for (let j = 0; j < 15; j++) { // Reduced attempts for better performance
                const result2 = generateFromOverlappingTrios();
                if (!result2 || !result2.combination) continue;
                
                const t2 = result2.combination.slice(0, 3).sort((a, b) => a - b);
                const t2Key = t2.join(',');
                const t2Info = getTrioOccurrenceInfo(t2);
                
                // Quick filter for t2 target range
                if (!isTrioInTargetRange(t2, targetHighRange === 60)) {
                    continue;
                }
                // --- END FILTER ---
                // Skip if the trios are the same or if t2 has been used before
                if (t1Key === t2Key || window.allUsedTrios.has(t2Key)) continue;
                
                // Check pattern-specific requirements
                if (pattern.type === 'trio-trio') {
                    // For trio-trio patterns, check max occurrences
                    if (t2Info.count > pattern.maxOccurrences || t2Info.count === 0) continue;
                } else if (pattern.type === 'trio-duo') {
                    // For trio-duo patterns, check if one trio matches the trio count and the other matches the duo count
                    const isTrioMatch = (t1Info.count === pattern.trioOccurrences && t2Info.duoCount === pattern.duoOccurrences) ||
                                     (t2Info.count === pattern.trioOccurrences && t1Info.duoCount === pattern.duoOccurrences);
                    if (!isTrioMatch) continue;
                }
                
                // Handle different pattern types
                if (pattern.type === 'trio-trio') {
                    // For trio-trio patterns (e.g., 2x-3x)
                    if (pattern.name.includes('-')) {
                        const [min, max] = pattern.name.split('-').map(s => parseInt(s));
                        const counts = [t1Info.count, t2Info.count].sort((a, b) => a - b);
                        if (counts[0] !== min || counts[1] !== max) continue;
                    }
                } else if (pattern.type === 'trio-duo') {
                    // For trio-duo patterns (e.g., trio(2x)-duo(3x))
                    // We need one trio to match the trio count and the other to match the duo count
                    const isTrioDuoMatch = 
                        (t1Info.count === pattern.trioOccurrences && t2Info.duoCount === pattern.duoOccurrences) ||
                        (t2Info.count === pattern.trioOccurrences && t1Info.duoCount === pattern.duoOccurrences);
                    
                    if (!isTrioDuoMatch) {
                        continue;
                    }
                    
                    // Ensure we have the right trio and duo assignments
                    if (t1Info.count === pattern.trioOccurrences) {
                        // t1 is the trio, t2 is the duo
                        trio1Info = t1Info;
                        trio2Info = t2Info;
                    } else {
                        // t2 is the trio, t1 is the duo
                        const temp = t1;
                        t1 = t2;
                        t2 = temp;
                        trio1Info = t2Info;
                        trio2Info = t1Info;
                    }
                }
                
                // Every 3rd combination, try to include higher numbers (40-69)
                const shouldIncludeHighNumbers = window.highNumberCounter % 3 === 0;
                if (shouldIncludeHighNumbers) {
                    const hasHighNumber = [...t1, ...t2].some(n => n >= 40);
                    if (!hasHighNumber) continue;
                }
                
                // Check if these trios share at least one number
                const sharedNumbers = t1.filter(num => t2.includes(num));
                if (sharedNumbers.length === 0) continue;
                
                // Skip if we've already used this trio pair
                const pairKey = `${t1Key}|${t2Key}`;
                if (usedTrios.has(pairKey)) continue;
                
                // Found a valid pair
                trio1 = t1;
                trio2 = t2;
                trio1Info = t1Info;
                trio2Info = t2Info;
                usedTrios.add(pairKey);
                break;
            }
            
            if (trio1 && trio2) break;
        }
        
        if (!trio1 || !trio2) continue;
        
        // Determine which trio has higher occurrence
        const [higherTrio, lowerTrio] = trio1Info.count >= trio2Info.count 
            ? [trio1, trio2] 
            : [trio2, trio1];
            
        const [higherTrioInfo, lowerTrioInfo] = trio1Info.count >= trio2Info.count 
            ? [trio1Info, trio2Info] 
            : [trio2Info, trio1Info];
        
        // Combine both trios and create a pool of all available numbers
        const allNumbers = [...new Set([...trio1, ...trio2])];
        let combination = [];
        
        // Randomly select numbers from the combined pool, with a bias towards higher numbers
        const pool = [...allNumbers];
        while (combination.length < 5 && pool.length > 0) {
            // Use a weighted random selection that favors higher numbers
            const weights = pool.map(n => {
                // Give higher numbers (40-69) more weight
                if (n >= 40) return 3; // Higher weight for high numbers
                return 1; // Standard weight for low numbers
            });
            
            // Calculate total weight
            const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
            let random = Math.random() * totalWeight;
            let selectedIndex = 0;
            
            // Find the selected index based on weights
            for (let i = 0; i < weights.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    selectedIndex = i;
                    break;
                }
            }
            
            // Add the selected number to the combination
            combination.push(pool[selectedIndex]);
            
            // Remove the selected number from the pool to avoid duplicates
            pool.splice(selectedIndex, 1);
        }
        
        // Ensure we have at least one high number (40-69) and one low number (1-39)
        const hasHighNumber = combination.some(n => n >= 40);
        const hasLowNumber = combination.some(n => n <= 39);
        
        if (!hasHighNumber || !hasLowNumber) {
            // Create a pool of all available numbers from both trios
            const allAvailable = [...new Set([...trio1, ...trio2])];
            
            // Try to find a number of the missing type
            const neededType = !hasHighNumber 
                ? n => n >= 40  // Need a high number
                : n => n <= 39; // Need a low number
                
            const candidates = allAvailable.filter(neededType);
            
            if (candidates.length > 0) {
                // Replace a random number in the combination with one of the needed type
                const replaceIndex = Math.floor(Math.random() * combination.length);
                const randomCandidate = candidates[Math.floor(Math.random() * candidates.length)];
                combination[replaceIndex] = randomCandidate;
            }
        }
        
        // If we still need more numbers, fill with random numbers
        if (combination.length < 5) {
            const allAvailable = [...new Set([...trio1, ...trio2])];
            const remainingNumbers = allAvailable.filter(n => !combination.includes(n));
            
            // Add remaining numbers from the trios first
            const spotsToFill = 5 - combination.length;
            if (remainingNumbers.length > 0) {
                // Add up to the number of spots we need to fill
                const toAdd = Math.min(spotsToFill, remainingNumbers.length);
                combination.push(...remainingNumbers.slice(0, toAdd));
            }
            
            // If we still need more numbers, generate random ones with a bias towards high numbers
            while (combination.length < 5) {
                // 70% chance to generate a high number (40-69)
                const generateHigh = Math.random() < 0.7;
                let randomNum;
                
                if (generateHigh) {
                    // Generate high number (40-69)
                    randomNum = Math.floor(Math.random() * 30) + 40;
                } else {
                    // Generate low number (1-39)
                    randomNum = Math.floor(Math.random() * 39) + 1;
                }
                
                // Add if not already in combination
                if (!combination.includes(randomNum)) {
                    combination.push(randomNum);
                }
            }
        }
        
        // Ensure we have exactly 5 unique numbers
        combination = [...new Set(combination)];
        if (combination.length < 5) {
            // If we don't have enough numbers, fill with random numbers
            const allNumbers = new Set([...trio1, ...trio2]);
            while (combination.length < 5) {
                const randomNum = Math.floor(Math.random() * 69) + 1;
                if (!allNumbers.has(randomNum)) {
                    combination.push(randomNum);
                    allNumbers.add(randomNum);
                }
            }
        }
        
        // Sort the combination
        combination = combination.sort((a, b) => a - b);
        
        // Find the most frequent duo in a trio
        const findMostFrequentDuo = (trio) => {
            const sortedTrio = [...trio].sort((a, b) => a - b);
            let maxDuo = [];
            let maxCount = 0;
            
            // Check all possible duos in the trio
            for (let i = 0; i < 3; i++) {
                for (let j = i + 1; j < 3; j++) {
                    const duo = [sortedTrio[i], sortedTrio[j]];
                    const count = countDuoOccurrences(duo);
                    if (count > maxCount) {
                        maxCount = count;
                        maxDuo = duo;
                    }
                }
            }
            
            return {
                numbers: maxDuo,
                count: maxCount
            };
        };
        
        // Format trio information for display
        const formatTrio = (trio, info, isTrio = true) => {
            // Ensure we have exactly 3 numbers in the trio
            const formattedTrio = trio.slice(0, 3).sort((a, b) => a - b);
            
            // Format counts for both trio and duo
            const trioCount = info.count > 0 ? `${info.count}x` : '0x';
            const duoCount = info.duoCount > 0 ? `${info.duoCount}x` : '0x';
            
            if (pattern.type === 'trio-duo') {
                if (isTrio) {
                    return `trio(${trioCount})`;
                } else {
                    const duoInfo = findMostFrequentDuo(trio);
                    return `${duoInfo.numbers[0]}-${duoInfo.numbers[1]} duo(${duoInfo.count}x)`;
                }
            }
            return `${formattedTrio.join('-')} (${trioCount})`;
        };
        
        // Create the combination object with both trios' info
        let displayText = '';
        if (pattern.type === 'trio-trio') {
            displayText = `Trio-Trio (${pattern.name}): ${formatTrio(higherTrio, higherTrioInfo)} & ${formatTrio(lowerTrio, lowerTrioInfo)}`;
        } else {
            const higherTrioText = formatTrio(higherTrio, higherTrioInfo, true);
            const lowerTrioText = formatTrio(lowerTrio, lowerTrioInfo, false);
            displayText = `${higherTrio.join('-')} ${higherTrioText} & ${lowerTrioText}`;
        }
        
        const combo = {
            numbers: combination,
            powerball: getNextPowerball(),
            pattern: pattern.name,
            basedOnTrio: displayText,
            trioInfo: displayText,
            patternType: pattern.type === 'trio-trio' ? 'Trio-Trio' : 'Trio-Duo'
        };
        
        combinations.push(combo);
    }
    
    // If we didn't find enough combinations, fill with random ones
    if (combinations.length < 6) {
        const remaining = 6 - combinations.length;
        for (let i = 0; i < remaining; i++) {
            const randomNums = [];
            while (randomNums.length < 5) {
                const num = Math.floor(Math.random() * 69) + 1;
                if (!randomNums.includes(num)) {
                    randomNums.push(num);
                }
            }
            combinations.push({
                numbers: randomNums.sort((a, b) => a - b),
                powerball: getNextPowerball(),
                pattern: 'Random',
                basedOnTrio: 'Random combination',
                trioInfo: 'Randomly generated',
                patternType: 'Random'
            });
        }
    }
    
    // Render the combinations
    renderPatternedCombinations(combinations);
}

// Helper function to adjust numbers to match pattern
function adjustToPattern(numbers, pattern) {
    const adjusted = [...numbers];
    
    // Adjust odd/even if needed
    if (pattern.odds !== undefined && pattern.evens !== undefined) {
        let oddCount = adjusted.filter(n => n % 2 === 1).length;
        const targetOdds = pattern.odds;
        
        while (oddCount !== targetOdds) {
            const index = Math.floor(Math.random() * adjusted.length);
            
            if (oddCount < targetOdds && adjusted[index] % 2 === 0) {
                // Need more odds, change even to odd
                adjusted[index] = Math.max(1, adjusted[index] - 1);
                oddCount++;
            } else if (oddCount > targetOdds && adjusted[index] % 2 === 1) {
                // Need fewer odds, change odd to even
                adjusted[index] = Math.min(68, adjusted[index] + 1);
                oddCount--;
            }
            
            // Ensure no duplicates
            if (new Set(adjusted).size !== adjusted.length) {
                adjusted[index] = numbers[index]; // Revert if duplicate created
            }
        }
    }
    
    // Adjust high/low if needed
    if (pattern.lows !== undefined && pattern.highs !== undefined) {
        let lowCount = adjusted.filter(n => n <= 39).length;
        const targetLows = pattern.lows;
        
        while (lowCount !== targetLows) {
            const index = Math.floor(Math.random() * adjusted.length);
            
            if (lowCount < targetLows && adjusted[index] > 39) {
                // Need more lows, change high to low
                adjusted[index] = Math.max(1, adjusted[index] % 40 + 1);
                lowCount++;
            } else if (lowCount > targetLows && adjusted[index] <= 39) {
                // Need fewer lows, change low to high
                adjusted[index] = Math.min(69, adjusted[index] + 40);
                lowCount--;
            }
            
            // Ensure no duplicates
            if (new Set(adjusted).size !== adjusted.length) {
                adjusted[index] = numbers[index]; // Revert if duplicate created
            }
        }
    }
    
    // Ensure we have at least one pair with same ending
    const endings = adjusted.map(n => n % 10);
    const uniqueEndings = [...new Set(endings)];
    
    if (uniqueEndings.length === 5) {
        // No duplicate endings, create a pair
        const endingToDuplicate = endings[Math.floor(Math.random() * 5)];
        let found = false;
        
        for (let i = 0; i < adjusted.length && !found; i++) {
            if (adjusted[i] % 10 !== endingToDuplicate) {
                const newNum = (Math.floor(adjusted[i] / 10) * 10) + endingToDuplicate;
                
                if (newNum > 0 && newNum <= 69 && !adjusted.includes(newNum)) {
                    adjusted[i] = newNum;
                    found = true;
                }
            }
        }
    }
    
    return adjusted;
}

// Render function for patterned combinations
function renderPatternedCombinations(combinations) {
    // Helper to get high ending badge for a combination
    function getHighEndingBadge(combo) {
        const max = Math.max(...combo.numbers);
        if (max >= 60 && max <= 69) return '<span class="frequency-badge" style="background:#ffe0e6;color:#e74c3c;">High Ending: 60-69</span>';
        if (max >= 50 && max <= 59) return '<span class="frequency-badge" style="background:#e0f7fa;color:#00796b;">High Ending: 50s</span>';
        if (max >= 40 && max <= 49) return '<span class="frequency-badge" style="background:#fffde7;color:#fbc02d;">High Ending: 40s</span>';
        if (max >= 30 && max <= 39) return '<span class="frequency-badge" style="background:#f3e6ff;color:#8e44ad;">High Ending: 30s</span>';
        return '';
    }
    const container = document.getElementById('generated-table');
    if (!container) return;
    
    let html = '<div class="patterned-combinations">';
    html += `
    <div style="margin-bottom: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0; color: #2c3e50; font-size: 1.2em;">Patterned Trio Combinations</h3>
            <button id="download-patterned-combinations" class="btn btn-primary" style="background: linear-gradient(90deg, #9b59b6 0%, #8e44ad 100%); border: none; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em; display: flex; align-items: center; gap: 5px;">
                <i class="fas fa-download"></i> Download
            </button>
        </div>
        <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
            <span style="background: #f3e6ff; color: #8e44ad; padding: 4px 10px; border-radius: 15px; font-size: 0.85em;">
                <i class="fas fa-project-diagram"></i> Smart Patterns
            </span>
            <span style="background: #e8f5e9; color: #27ae60; padding: 4px 10px; border-radius: 15px; font-size: 0.85em;">
                <i class="fas fa-random"></i> Round-Robin Trios
            </span>
            <span style="background: #e3f2fd; color: #1976d2; padding: 4px 10px; border-radius: 15px; font-size: 0.85em;">
                <i class="fas fa-sync-alt"></i> Duplicate Endings
            </span>
        </div>
    `;
    
    combinations.forEach((combo, index) => {
        const endings = combo.numbers.map(n => n % 10);
        const endingCounts = {};
        endings.forEach(e => endingCounts[e] = (endingCounts[e] || 0) + 1);
        const duplicateEndings = Object.entries(endingCounts).filter(([e, count]) => count > 1);
        const lowCount = combo.numbers.filter(n => n <= 39).length;
        const oddCount = combo.numbers.filter(n => n % 2 === 1).length;
        
        // Check if this combination has appeared before
        const history = getComboHistory(combo.numbers);
        
        html += `
        <div class="patterned-card" style="
            background: white; 
            border-radius: 6px; 
            padding: 8px; 
            margin-bottom: 8px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.05); 
            border-left: 3px solid #9b59b6;
        ">
            <div style="margin-bottom: 6px;">
                <div style="display: flex; flex-direction: column; gap: 3px;">
                        <div style="display: flex; flex-direction: column; gap: 4px;">
                            <span style="background: #e3f2fd; color: #1976d2; padding: 4px 8px; border-radius: 12px; font-size: 0.8em;
                                white-space: normal; word-break: break-word;">
                                <i class="fas fa-project-diagram"></i> ${combo.basedOnTrio || 'No pattern info'}
                            </span>
                            ${getHighEndingBadge(combo)}
                        </div>
                        ${history.appeared ? `
                        <div style="margin-top: 6px; padding: 6px 8px; background: #fff8e1; border-radius: 4px; border-left: 3px solid #e67e22;">
                            <div style="font-size: 0.8em; color: #e67e22; margin-bottom: 4px; font-weight: 500;">
                                <i class="fas fa-history"></i> ${history.isPartialMatch ? 'Partial Match' : 'Exact Match'} (${history.count} time${history.count > 1 ? 's' : ''})
                            </div>
                            ${history.matchedNumbers ? `
                            <div style="font-size: 0.8em; color: #7f8c8d; margin-bottom: 6px;">
                                <strong>Matched Numbers:</strong> ${history.matchedNumbers.sort((a, b) => a - b).join(', ')}
                            </div>` : ''}
                            ${history.dates && history.dates.length > 0 ? `
                            <div style="font-size: 0.8em; color: #7f8c8d; margin-bottom: 6px;">
                                <strong>Recent:</strong> ${history.dates.slice(0, 2).map(d => {
                                    try {
                                        // If it's already a formatted string, use it as is
                                        if (typeof d === 'string' && d.includes('/')) {
                                            return d;
                                        }
                                        // If it's a Date object, format it
                                        if (d instanceof Date) {
                                            return d.toLocaleDateString();
                                        }
                                        // If it's a timestamp, convert to Date then format
                                        if (typeof d === 'number') {
                                            return new Date(d).toLocaleDateString();
                                        }
                                        return 'Unknown date';
                                    } catch (e) {
                                        console.error('Error formatting date:', e, d);
                                        return 'Invalid date';
                                    }
                                }).filter(d => d !== 'Invalid date').join(', ')}${history.count > 2 ? `, and ${history.count - 2} more` : ''}
                            </div>` : ''}
                            ${history.powerballs && history.powerballs.length > 0 ? `
                            <div style="font-size: 0.8em; color: #7f8c8d;">
                                <strong>Powerballs:</strong> ${history.powerballs.join(', ')}
                            </div>` : ''}
                        </div>` : `
                        <span style="background: #e3f2fd; color: #1976d2; padding: 2px 8px; border-radius: 12px; font-size: 0.75em;
                            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; display: inline-block;">
                            <i class="fas fa-check-circle"></i> New combination
                        </span>`}
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-bottom: 12px; flex-wrap: wrap;">
                ${combo.numbers.map(num => {
                    const isLow = num <= 39;
                    const isOdd = num % 2 === 1;
                    const ending = num % 10;
                    const isDuplicate = duplicateEndings.some(([e]) => parseInt(e) === ending);
                    
                    return `<div style="
                        width: 32px; 
                        height: 32px; 
                        border-radius: 50%; 
                        background: ${isLow ? 
                            'linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%)' : 
                            'linear-gradient(135deg, #3498db 0%, #2980b9 100%)'}; 
                        color: white; 
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        font-weight: bold; 
                        font-size: 0.95em; 
                        box-shadow: 0 1px 2px rgba(0,0,0,0.1);
                        border: ${isDuplicate ? '2px solid #f1c40f' : 'none'};
                        position: relative;
                    ">
                        ${num}
                        ${isDuplicate ? `
                            <span style="
                                position: absolute;
                                bottom: -5px;
                                right: -5px;
                                background: #f1c40f;
                                color: #000;
                                border-radius: 50%;
                                width: 16px;
                                height: 16px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                font-size: 10px;
                                font-weight: bold;
                            ">${ending}</span>
                        ` : ''}
                    </div>`;
                }).join('')}
                <div style="width: 32px; height: 32px; border-radius: 50%; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.95em; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">
                    ${combo.powerball}
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; font-size: 0.85em; color: #7f8c8d;">
                <span><i class="fas fa-hashtag"></i> Sum: ${combo.numbers.reduce((a, b) => a + b, 0)}</span>
                <span><i class="fas ${duplicateEndings.length > 0 ? 'fa-check-circle' : 'fa-times-circle'}" style="color: ${duplicateEndings.length > 0 ? '#27ae60' : '#e74c3c'}"></i> ${duplicateEndings.length > 0 ? 
                    `${duplicateEndings.length} pair${duplicateEndings.length > 1 ? 's' : ''} (${duplicateEndings.map(([e, c]) => `${c}x${e}`).join(', ')})` : 
                    'No duplicate endings'}</span>
                <span><i class="fas fa-chart-pie"></i> ${lowCount}L/${5-lowCount}H, ${oddCount}O/${5-oddCount}E</span>
            </div>
        </div>`;
    });
    
    html += '</div>';
    container.innerHTML = html;
    
    // Add download handler for the new button
    document.getElementById('download-patterned-combinations')?.addEventListener('click', function() {
        const container = document.querySelector('.patterned-combinations');
        if (!container) return;
        
        const combinations = [];
        const comboElements = container.querySelectorAll('.patterned-card');
        
        comboElements.forEach(comboEl => {
            const numbers = Array.from(comboEl.querySelectorAll('div[style*="background: linear-gradient"][style*="border-radius: 50%"]'))
                .filter(el => !el.textContent.includes('PB') && !el.textContent.match(/^\d+\s*\d+$/))
                .map(ball => parseInt(ball.textContent.trim()));
                
            const powerball = parseInt(comboEl.querySelector('div[style*="background: linear-gradient"][style*="border-radius: 50%"]:last-child')?.textContent || '0');
            const pattern = comboEl.querySelector('span[style*="background: #f3e6ff"]')?.textContent.trim() || 'Patterned';
            
            combinations.push({
                numbers: numbers,
                powerball: powerball,
                pattern: pattern,
                basedOnTrio: ''
            });
        });
        
        if (combinations.length > 0) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `patterned-combinations-${timestamp}.txt`;
            const text = formatCombinationsForDownload(combinations);
            downloadTextAsFile(text, filename);
        } else {
            alert('No combinations to download. Please generate some combinations first.');
        }
    });
}

function generateEnhancedTrioCombinations() {
        const combinations = [];
        const maxAttempts = 1000;
        let attempts = 0;
        
        // Generate 5 combinations with different patterns
        while (combinations.length < 5 && attempts < maxAttempts) {
            attempts++;
            
            // Get overlapping trios from historical data
            let overlappingResult;
            try {
                overlappingResult = generateFromOverlappingTrios();
                if (!overlappingResult || !overlappingResult.combination || !Array.isArray(overlappingResult.combination) || overlappingResult.combination.length !== 5) {
                    console.error('Failed to generate valid overlapping trios', overlappingResult);
                    continue;
                }
            } catch (error) {
                console.error('Error in generateFromOverlappingTrios:', error);
                continue;
            }
            
            // Get the base combination from overlapping trios
            const baseCombination = [...overlappingResult.combination];
            const trioKey = baseCombination.slice(0, 3).sort((a, b) => a - b).join(',');
            
            // Skip if we've used this trio before
            if (usedEnhancedTrios.has(trioKey)) {
                console.log('Skipping used trio:', trioKey);
                continue;
            }
            
            // Determine pattern based on combination index
            const pattern = combinations.length % 5; // Now 5 patterns (0-4)
            console.log('Using pattern:', pattern, 'for combination', combinations.length + 1);
            
            // Adjust numbers to match the desired pattern
            let adjustedCombination = [...baseCombination];
            
            // Ensure the combination matches the pattern
            switch (pattern) {
                case 0: // 2 odd, 3 even
                    adjustParity(adjustedCombination, 2, 3);
                    break;
                case 1: // 3 odd, 2 even
                    adjustParity(adjustedCombination, 3, 2);
                    break;
                case 2: // 2 low (1-39), 3 high (40-69)
                    adjustRange(adjustedCombination, 2, 3);
                    break;
                case 3: // 3 low (1-39), 2 high (40-69)
                    adjustRange(adjustedCombination, 3, 2);
                    break;
                case 4: // No double digits (1-9, 10-19, 20-29, etc.)
                    adjustedCombination = adjustedCombination.map(num => {
                        // Convert to single digit by taking modulo 9 + 1 (1-9)
                        return ((num - 1) % 9) + 1;
                    });
                    // Ensure we still have unique numbers
                    if (new Set(adjustedCombination).size < 5) continue;
                    break;
            }
            
            // Ensure no duplicates and valid range
            const uniqueNums = new Set(adjustedCombination);
            if (uniqueNums.size !== 5) continue;
            if (Math.min(...adjustedCombination) < 1 || Math.max(...adjustedCombination) > 69) continue;
            
            // Check for duplicate endings (last digit)
            const endings = adjustedCombination.map(n => n % 10);
            const uniqueEndings = new Set(endings);
            
            // Skip if we don't have at least one duplicate ending
            // Except for the no-double-digits pattern
            if (pattern !== 4 && uniqueEndings.size >= 5) continue;
            
            // Ensure we have valid numbers before adding to combinations
            const sortedCombination = [...adjustedCombination].sort((a, b) => a - b);
            if (sortedCombination.some(isNaN) || sortedCombination.length !== 5) {
                console.error('Invalid combination generated:', sortedCombination);
                continue;
            }
            
            // Add to combinations
            combinations.push({
                numbers: sortedCombination,
                powerball: getNextPowerball(),
                pattern: pattern,
                basedOnTrio: overlappingResult.basedOnTrio || 'Random Trio'
            });
            
            console.log('Added combination:', sortedCombination, 'with pattern', pattern);
            
            // Add to used trios for round-robin
            usedEnhancedTrios.add(trioKey);
            enhancedTrioIndex++;
            
            // Reset if we've used all trios
            if (enhancedTrioIndex >= 100) {
                usedEnhancedTrios.clear();
                enhancedTrioIndex = 0;
            }
        }
        
        // Render the combinations
        renderEnhancedCombinations(combinations);
    }
    
    // Helper function to adjust parity of numbers in a combination
    function adjustParity(combination, targetOdd, targetEven) {
        // First, count current parity
        let currentOdd = 0;
        const odds = [];
        const evens = [];
        
        // Categorize numbers
        combination.forEach((num, index) => {
            if (num % 2 !== 0) {
                currentOdd++;
                odds.push(index);
            } else {
                evens.push(index);
            }
        });
        
        // Adjust parity if needed
        if (currentOdd !== targetOdd) {
            const toChange = Math.abs(targetOdd - currentOdd);
            const sourceArray = currentOdd > targetOdd ? odds : evens;
            const targetParity = currentOdd > targetOdd ? 'even' : 'odd';
            
            // Change numbers to match target parity
            for (let i = 0; i < Math.min(toChange, sourceArray.length); i++) {
                const idx = sourceArray[i];
                combination[idx] = generateNumberWithParity(1, 69, targetParity, combination);
            }
        }
        
        // Final verification
        const finalOdds = combination.filter(n => n % 2 !== 0).length;
        if (finalOdds !== targetOdd) {
            // If still not matching, force it by regenerating the last few numbers
            const neededOdds = targetOdd - finalOdds;
            const startIdx = Math.max(0, combination.length - Math.abs(neededOdds));
            
            for (let i = startIdx; i < combination.length; i++) {
                const targetParity = neededOdds > 0 ? 'odd' : 'even';
                combination[i] = generateNumberWithParity(1, 69, targetParity, combination);
            }
        }
    }
    
    // Helper function to generate number with specific parity
    function generateNumberWithParity(min, max, parity, exclude = []) {
        const excludeSet = new Set(exclude);
        const isEven = parity === 'even';
        
        // First, try to find a suitable number in the range
        for (let i = 0; i < 100; i++) {
            const num = getRandomInt(min, max);
            if ((num % 2 === 0) === isEven && !excludeSet.has(num)) {
                return num;
            }
        }
        
        // Fallback: find any number with correct parity
        const start = isEven ? 2 : 1;
        for (let num = start; num <= max; num += 2) {
            if (!excludeSet.has(num)) {
                return num;
            }
        }
        
        // Last resort: return any number not in exclude
        for (let num = min; num <= max; num++) {
            if (!excludeSet.has(num)) {
                return num;
            }
        }
        
        // Should never get here if called with valid parameters
        return getRandomInt(min, max);
    }
    
    // Helper function to generate number within a specific range
    function generateNumberWithRange(min, max, exclude = []) {
        const excludeSet = new Set(exclude);
        
        // First, try to find a suitable number in the range
        for (let i = 0; i < 100; i++) {
            const num = getRandomInt(min, max);
            if (!excludeSet.has(num)) {
                return num;
            }
        }
        
        // Fallback: find any available number in range
        for (let num = min; num <= max; num++) {
            if (!excludeSet.has(num)) {
                return num;
            }
        }
        
        // Last resort: return any number not in exclude (even if outside range)
        for (let num = 1; num <= 69; num++) {
            if (!excludeSet.has(num)) {
                return num;
            }
        }
        
        // Should never get here if called with valid parameters
        return getRandomInt(1, 69);
    }

    // Helper function to adjust range of numbers in a combination
    function adjustRange(combination, targetLow, targetHigh) {
        // First, count current ranges
        let currentLow = 0;
        const lows = [];
        const highs = [];
        
        // Categorize numbers
        combination.forEach((num, index) => {
            if (num <= 39) {
                currentLow++;
                lows.push(index);
            } else {
                highs.push(index);
            }
        });
        
        // Adjust range if needed
        if (currentLow !== targetLow) {
            const toChange = Math.abs(targetLow - currentLow);
            const sourceArray = currentLow > targetLow ? lows : highs;
            const targetRange = currentLow > targetLow ? 'high' : 'low';
            
            // Change numbers to match target range
            for (let i = 0; i < Math.min(toChange, sourceArray.length); i++) {
                const idx = sourceArray[i];
                combination[idx] = targetRange === 'low' 
                    ? generateNumberWithRange(1, 39, combination)
                    : generateNumberWithRange(40, 69, combination);
            }
        }
        
        // Final verification and fix any duplicates
        const finalLows = combination.filter(n => n <= 39).length;
        if (finalLows !== targetLow) {
            // If still not matching, force it by regenerating the last few numbers
            const neededLows = targetLow - finalLows;
            const startIdx = Math.max(0, combination.length - Math.abs(neededLows));
            
            for (let i = startIdx; i < combination.length; i++) {
                combination[i] = neededLows > 0
                    ? generateNumberWithRange(1, 39, combination)
                    : generateNumberWithRange(40, 69, combination);
            }
        }
        
        // One final check for duplicates
        const uniqueNums = new Set(combination);
        if (uniqueNums.size < 5) {
            const used = new Set();
            for (let i = 0; i < combination.length; i++) {
                if (used.has(combination[i])) {
                    combination[i] = generateNumberWithRange(1, 69, combination);
                }
                used.add(combination[i]);
            }
        }
    }
    
    // Helper function to check if a number is a single digit
    function isSingleDigit(num) {
        return num >= 1 && num <= 9;
    }
    
    // Helper function to check if all numbers in a combination are single digits
    function hasNoDoubleDigits(combination) {
        return combination.every(num => isSingleDigit(num));
    }
    
    // Function to format combinations for download
    function formatCombinationsForDownload(combinations) {
        const patternNames = [
            '2 Odd, 3 Even',
            '3 Odd, 2 Even',
            '2 Low (1-39), 3 High (40-69)',
            '3 Low (1-39), 2 High (40-69)',
            'No Double Digits (1-9)'
        ];
        
        let text = 'Powerball Enhanced Trio Generator - Generated Combinations\n';
        text += 'Generated on: ' + new Date().toLocaleString() + '\n\n';
        
        combinations.forEach((combo, index) => {
            const patternName = patternNames[combo.pattern] || 'Custom Pattern';
            const numbers = combo.numbers.join(', ');
            const powerball = combo.powerball;
            const basedOnTrio = combo.basedOnTrio || 'Overlapping Trios';
            
            text += `Combination ${index + 1}:\n`;
            text += `Numbers: ${numbers}\n`;
            text += `Powerball: ${powerball}\n`;
            text += `Pattern: ${patternName}\n`;
            text += '-----------------------------------\n\n';
        });
        
        return text;
    }
    
    // Function to download text as file
    function downloadTextAsFile(text, filename) {
        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    // Render the enhanced combinations
    function renderEnhancedCombinations(combinations) {
        const container = document.getElementById('generated-table');
        if (!container) return;
        
        const patternNames = [
            '2 Odd, 3 Even',
            '3 Odd, 2 Even',
            '2 Low (1-39), 3 High (40-69)',
            '3 Low (1-39), 2 High (40-69)',
            'No Double Digits (1-9)'
        ];
        
        let html = '<div class="enhanced-combinations">';
        html += `
        <div style="margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; color: #2c3e50; font-size: 1.2em;">Enhanced Trio Combinations (Using Overlapping Trios)</h3>
                <button id="download-combinations" class="btn btn-primary" style="background: linear-gradient(90deg, #4CAF50 0%, #2E7D32 100%); border: none; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em; display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-download"></i> Download
                </button>
            </div>
            <div style="display: flex; flex-wrap: wrap; gap: 4px; margin: 6px 0; justify-content: center;">
                <span style="background: #e8f5e9; color: #27ae60; padding: 4px 10px; border-radius: 15px; font-size: 0.85em;">
                    <i class="fas fa-sync-alt"></i> Cycling through patterns
                </span>
                <span style="background: #e3f2fd; color: #1976d2; padding: 4px 10px; border-radius: 15px; font-size: 0.85em;">
                    <i class="fas fa-random"></i> Using historical overlapping trios
                </span>
                <span style="background: #fff3e0; color: #f39c12; padding: 4px 10px; border-radius: 15px; font-size: 0.85em;">
                    <i class="fas fa-check-double"></i> Ensures duplicate endings
                </span>
            </div>
        </div>`;
        
        combinations.forEach((combo, index) => {
            const patternName = patternNames[combo.pattern];
            const endings = combo.numbers.map(n => n % 10);
            const endingCounts = endings.reduce((acc, curr) => {
                acc[curr] = (acc[curr] || 0) + 1;
                return acc;
            }, {});
            
            // Calculate stats for the combination
            const oddCount = combo.numbers.filter(n => n % 2 !== 0).length;
            const evenCount = 5 - oddCount;
            const lowCount = combo.numbers.filter(n => n <= 39).length;
            const highCount = 5 - lowCount;
            const pattern = combo.pattern || 0;
            
            // Check if this combination has been drawn before and get draw dates
            const sortedCombo = [...combo.numbers].sort((a, b) => a - b);
            const comboKey = sortedCombo.join(',');
            
            const drawnBefore = [];
            const partialMatches = [];
            
            allMainDraws.forEach(draw => {
                if (!draw || !draw.numbers || !Array.isArray(draw.numbers)) return;
                
                const sortedDraw = [...draw.numbers].sort((a, b) => a - b);
                
                // Count how many numbers match
                const matchingNumbers = sortedCombo.filter(num => sortedDraw.includes(num));
                const matchCount = matchingNumbers.length;
                
                // If all numbers match (exact match)
                if (matchCount === 5) {
                    drawnBefore.push({
                        date: draw.date || 'Unknown date',
                        numbers: sortedDraw,
                        matchType: 'exact',
                        matchCount: 5
                    });
                }
                // If 4 numbers match (partial match)
                else if (matchCount >= 4) {
                    partialMatches.push({
                        date: draw.date || 'Unknown date',
                        numbers: sortedDraw,
                        matchType: 'partial',
                        matchCount: matchCount,
                        matchingNumbers: matchingNumbers
                    });
                }
            });
            
            // Show partial matches if no exact matches found
            const matchesToShow = drawnBefore.length > 0 ? drawnBefore : partialMatches;
            const isDrawnBefore = matchesToShow.length > 0;
            const drawDates = matchesToShow.map(d => {
                let formattedDate = 'Unknown date';
                try {
                    if (d.date) {
                        const dateObj = typeof d.date === 'string' ? new Date(d.date) : d.date;
                        formattedDate = dateObj.toLocaleDateString('en-US', {
                            year: 'numeric',
                            month: 'short',
                            day: 'numeric'
                        });
                    }
                } catch (e) {
                    console.error('Error formatting date:', e);
                }
                
                const matchInfo = d.matchType === 'partial' && d.matchingNumbers
                    ? ` (${d.matchCount} numbers: ${d.matchingNumbers.join(', ')})` 
                    : '';
                return d.date ? `${d.date}${matchInfo}` : null;
            }).filter(Boolean).join(', ');
            
            html += `
            <div class="combo-card" style="background: #fff; border-radius: 12px; padding: 16px; margin-bottom: 20px; box-shadow: 0 3px 10px rgba(0,0,0,0.08); border-left: 5px solid ${isDrawnBefore ? '#e74c3c' : '#2ecc70'}; position: relative;">
                <!-- Header with pattern -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px; flex-wrap: wrap; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="background: #f0f4ff; color: #3498db; padding: 5px 12px; border-radius: 15px; font-size: 0.85em; font-weight: 500;">
                            <i class="fas ${pattern === 0 || pattern === 1 ? 'fa-exchange-alt' : 'fa-arrows-alt-v'}" style="margin-right: 6px;"></i>
                            ${patternName}
                        </span>
                    </div>
                    
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; background: #f8f9fa; padding: 4px 12px; border-radius: 12px; font-size: 0.85em; border: 1px solid #e0e0e0; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
                            <span style="color: #e65100; font-weight: 600;">${oddCount} Odd</span> 
                            <span style="margin: 0 6px; color: #bdbdbd;">|</span>
                            <span style="color: #1b5e20; font-weight: 600;">${evenCount} Even</span>
                        </div>
                        <div style="display: flex; align-items: center; background: #f8f9fa; padding: 4px 12px; border-radius: 12px; font-size: 0.85em; border: 1px solid #e0e0e0; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
                            <span style="color: #b71c1c; font-weight: 600;">${lowCount} Low</span> 
                            <span style="margin: 0 6px; color: #bdbdbd;">|</span>
                            <span style="color: #0d47a1; font-weight: 600;">${highCount} High</span>
                        </div>
                    </div>
                </div>
                
                <!-- Match Info -->
                ${matchesToShow.length > 0 ? 
                    `<div style="background: #ffebee; color: #e74c3c; padding: 10px 15px; border-radius: 10px; margin: 10px 0; font-size: 0.85em;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-weight: 600;">
                            <i class="fas fa-exclamation-triangle"></i>
                            <span>Drawn ${matchesToShow.length} time${matchesToShow.length !== 1 ? 's' : ''}</span>
                        </div>
                        <div style="font-size: 0.95em; color: #b71c1c; line-height: 1.5;">
                            ${matchesToShow.map(d => {
                                let formattedDate = 'Unknown date';
                                try {
                                    if (d.date) {
                                        const dateObj = typeof d.date === 'string' ? new Date(d.date) : d.date;
                                        formattedDate = dateObj.toLocaleDateString('en-US', {
                                            year: 'numeric',
                                            month: 'short',
                                            day: 'numeric'
                                        });
                                    }
                                } catch (e) {
                                    console.error('Error formatting date:', e);
                                }
                                
                                const numbers = d.numbers.join(', ');
                                const matchInfo = d.matchType === 'partial' && d.matchingNumbers
                                    ? ` (${d.matchCount} matching: ${d.matchingNumbers.join(', ')})` 
                                    : '';
                                return `• ${formattedDate}: ${numbers}${matchInfo}`;
                            }).join('<br>')}
                        </div>
                    </div>` : 
                    ''
                }
                
                <!-- Numbers -->
                <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin: 12px 0 16px 0;">
                ${combo.numbers.map((num, i) => {
                    const ending = endings[i];
                    const isDuplicate = endingCounts[ending] > 1;
                    const isLow = num <= 39;
                    const isOdd = num % 2 !== 0;
                    
                    // Color scheme matching indicators
                    let bgColor = isLow ? '#ffebee' : '#e3f2fd'; // Light pink for low, light blue for high
                    let textColor = isOdd ? '#e65100' : '#1b5e20'; // Dark orange for odd, dark green for even
                    let borderColor = isLow ? '#b71c1c' : '#0d47a1'; // Dark red for low, dark blue for high
                    
                    return `
                    <div style="
                        width: 40px;
                        height: 40px;
                        border-radius: 50%;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        font-weight: 700;
                        background: ${bgColor};
                        color: ${textColor};
                        border: 2px solid ${isDuplicate ? '#f1c40f' : borderColor};
                        box-shadow: ${isDuplicate ? '0 0 0 2px #f1c40f' : '0 2px 4px rgba(0,0,0,0.2)'};
                        position: relative;
                        transition: all 0.2s ease;
                    ">
                        <div style="font-size: 1.1em;">${num}</div>
                        ${isDuplicate ? `
                        <div style="
                            position: absolute;
                            top: -4px;
                            right: -4px;
                            background: #f1c40f;
                            color: #000;
                            width: 18px;
                            height: 18px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 11px;
                            font-weight: bold;
                            border: 2px solid #fff;
                            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                        ">${endingCounts[ending]}</div>` : ''}
                        <div style="
                            position: absolute;
                            bottom: -16px;
                            font-size: 10px;
                            color: ${isDuplicate ? '#f1c40f' : '#7f8c8d'};
                            font-weight: ${isDuplicate ? 'bold' : 'normal'};
                            text-shadow: ${isDuplicate ? '0 0 2px rgba(241, 196, 15, 0.3)' : 'none'};
                        ">${ending}</div>
                    </div>`;
                }).join('')}
                <div style="
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        margin-left: 4px;
                    ">
                        <div style="
                            width: 40px;
                            height: 40px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: 700;
                            background: linear-gradient(135deg, #ff6b6b 0%, #ff4757 100%);
                            color: white;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            position: relative;
                            z-index: 1;
                        ">
                            ${combo.powerball}
                            <div style="
                                position: absolute;
                                bottom: -16px;
                                font-size: 10px;
                                color: #ff6b6b;
                                font-weight: 600;
                            ">PB</div>
                        </div>
                    </div>
                </div>
                
                <!-- Footer with additional info -->
                <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 12px; border-top: 1px solid #f0f0f0; margin-top: 8px; font-size: 0.8em; color: #7f8c8d; flex-wrap: wrap; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <i class="fas fa-info-circle"></i>
                            <span>${Object.entries(endingCounts)
                                .filter(([_, count]) => count > 1)
                                .map(([ending, count]) => `Ending ${ending}: ${count}x`)
                                .join(', ') || 'No duplicate endings'}</span>
                        </div>
                        
                        ${isDrawnBefore ? 
                            `<div style="display: flex; align-items: center; gap: 4px; color: #e74c3c;" 
                              title="${drawDates}">
                                <i class="fas fa-history"></i> 
                                <span>Drawn: ${drawnBefore.length} time${drawnBefore.length > 1 ? 's' : ''}</span>
                            </div>` : 
                            ''
                        }
                    </div>
                    
                    <div style="color: #9b59b6; font-size: 0.85em; display: flex; align-items: center; gap: 4px;">
                        <i class="fas fa-project-diagram"></i>
                        <span>${combo.basedOnTrio || 'Overlapping trios'}</span>
                    </div>
                </div>
            </div>`;
        });
        
        html += '</div>';
        container.innerHTML = html;
    }
    
    // Add event listeners
    document.getElementById('generate-enhanced-trios')?.addEventListener('click', generateEnhancedTrioCombinations);
    document.getElementById('generate-advanced-trios')?.addEventListener('click', generateAdvancedTrioCombinations);
    document.getElementById('generate-patterned-trios')?.addEventListener('click', generatePatternedTrioCombinations);
    
    // Add download button event listener
    document.addEventListener('click', function(e) {
        if (e.target && e.target.id === 'download-combinations') {
            const container = document.querySelector('.enhanced-combinations');
            if (!container) return;
            
            const combinations = [];
            const comboElements = container.querySelectorAll('.combo-card');
            
            comboElements.forEach(comboEl => {
                const numbers = Array.from(comboEl.querySelectorAll('.ball')).map(ball => parseInt(ball.textContent));
                const powerball = parseInt(comboEl.querySelector('.powerball')?.textContent || '0');
                const pattern = comboEl.getAttribute('data-pattern') || '0';
                const basedOnTrio = comboEl.getAttribute('data-trio') || 'Overlapping Trios';
                
                combinations.push({
                    numbers: numbers,
                    powerball: powerball,
                    pattern: parseInt(pattern),
                    basedOnTrio: basedOnTrio
                });
            });
            
            if (combinations.length > 0) {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `powerball-combinations-${timestamp}.txt`;
                const text = formatCombinationsForDownload(combinations);
                downloadTextAsFile(text, filename);
            } else {
                alert('No combinations to download. Please generate some combinations first.');
            }
        }
    });
    
    // Handle frequent trios button
    function initializeTrioButton() {
        const generateFromTriosBtn = document.getElementById('generate-from-trios');
        console.log('Trio button element:', generateFromTriosBtn);
        if (generateFromTriosBtn) {
            // Remove any existing click handlers to prevent duplicates
            const newBtn = generateFromTriosBtn.cloneNode(true);
            generateFromTriosBtn.parentNode.replaceChild(newBtn, generateFromTriosBtn);
            
            console.log('Adding click handler to trio button');
            newBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                console.log('Trio button clicked');
                console.log('sortedTriplets available:', window.sortedTriplets ? 'Yes' : 'No');
                if (window.sortedTriplets) {
                    console.log('Number of available trios:', window.sortedTriplets.length);
                    // Clear any previous error messages
                    const container = document.getElementById('generated-table');
                    if (container) {
                        container.innerHTML = '';
                    }
                    // Render new combinations
                    renderCombinations(5, true);
                } else {
                    console.error('No sortedTriplets data available');
                    const container = document.getElementById('generated-table');
                    if (container) {
                        container.innerHTML = '<div style="color: #e74c3c; padding: 15px; text-align: center;">Loading data... Please try again in a moment.</div>';
                    }
                }
            });
        } else {
            console.error('Could not find generate-from-trios button');
        }
    }
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM fully loaded');
        // Initialize the trio button
        initializeTrioButton();
        
        // Show home tab by default (guard for missing elements)
        const homeTab = document.getElementById('home-tab');
        if (homeTab) homeTab.style.display = 'block';
        const historyTab = document.getElementById('history-tab');
        if (historyTab) historyTab.style.display = 'none';
        // Do NOT call analyzeFrequentSets here. It is called after CSV loads.
        
        // Generate button handlers - number-based generation removed
        // Add clear/deselect handlers for Section 2 and 3
        const clearDuoBtn = document.getElementById('clear-duo-selection-btn');
        if (clearDuoBtn) {
            clearDuoBtn.onclick = function() {
                const duo1Select = document.getElementById('duo1-select');
                const duo2Select = document.getElementById('duo2-select');
                duo1Select.selectedIndex = -1;
                duo2Select.selectedIndex = -1;
                document.getElementById('built-duo-combo-result').innerHTML = '';
                document.getElementById('build-duo-combo-btn').disabled = true;
            };
        }
        const clearComboBtn = document.getElementById('clear-combo-selection-btn');
        if (clearComboBtn) {
            clearComboBtn.onclick = function() {
                const comboDuoSelect = document.getElementById('combo-duo-select');
                const comboTrioSelect = document.getElementById('combo-trio-select');
                comboDuoSelect.selectedIndex = -1;
                comboTrioSelect.selectedIndex = -1;
                document.getElementById('built-combo-result').innerHTML = '';
                document.getElementById('build-combo-btn').disabled = true;
            };
        }

        // Tab switching logic
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                // Remove active class from all buttons
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                // Add active class to clicked button
                this.classList.add('active');
                
                // For history tab
                if (this.getAttribute('data-tab') === 'history') {
                    document.getElementById('home-tab').style.display = 'none';
                    document.getElementById('history-tab').style.display = 'block';
                    renderHistoryTable();
                } else {
                    document.getElementById('home-tab').style.display = 'block';
                    document.getElementById('history-tab').style.display = 'none';
                }
            });
        });

        // Add event listener for building combinations from duos
        const buildDuoBtn = document.getElementById('build-duo-combo-btn');
        if (buildDuoBtn) {
            buildDuoBtn.addEventListener('click', function() {
                const duo1Val = document.getElementById('duo1-select').value;
                const duo2Val = document.getElementById('duo2-select').value;
                if (!duo1Val || !duo2Val) {
                    alert('Please select two valid duos to combine');
                    return;
                }
                const duo1 = duo1Val.split('-').map(Number);
                const duo2 = duo2Val.split('-').map(Number);
                if (duo1.length === 2 && duo2.length === 2) {
                    const combined = [...new Set([...duo1, ...duo2])];
                    if (combined.length === 4) {
                        const result = document.getElementById('built-duo-combo-result');
                        result.innerHTML = `
                            <div class="result-card fade-in">
                                <div class="result-title">Generated Combination</div>
                                <div class="result-balls">
                                    ${combined.sort((a,b) => a-b).map(n => `<span class='generated-ball'>${n}</span>`).join(' ')}
                                </div>
                            </div>
                        `;
                        return;
                    }
                }
                alert('Please select two valid duos to combine');
            });
            // Enable/disable build button logic
            const duo1Select = document.getElementById('duo1-select');
            const duo2Select = document.getElementById('duo2-select');
            [duo1Select, duo2Select].forEach(sel => sel.addEventListener('change', function() {
                buildDuoBtn.disabled = !(duo1Select.value && duo2Select.value);
            }));
        }
        // Section 3: Combo build button logic
        const buildComboBtn = document.getElementById('build-combo-btn');
        if (buildComboBtn) {
            buildComboBtn.addEventListener('click', function() {
                const duoVal = document.getElementById('combo-duo-select').value;
                const trioVal = document.getElementById('combo-trio-select').value;
                if (!duoVal || !trioVal) {
                    alert('Please select a valid duo and trio to combine');
                    return;
                }
                const duo = duoVal.split('-').map(Number);
                const trio = trioVal.split('-').map(Number);
                if (duo.length === 2 && trio.length === 3) {
                    const combined = [...new Set([...duo, ...trio])];
                    if (combined.length === 5) {
                        const result = document.getElementById('built-combo-result');
                        result.innerHTML = `
    <div class="result-card fade-in">
        <div class="result-title">Generated Combination</div>
        <div class="result-balls">
            ${combined.sort((a,b) => a-b).map(n => `<span class='generated-ball'>${n}</span>`).join(' ')}
        </div>
    </div>
`;
                        return;
                    }
                }
                alert('Please select a valid duo and trio to combine');
            });
            // Enable/disable build button logic
            const comboDuoSelect = document.getElementById('combo-duo-select');
            const comboTrioSelect = document.getElementById('combo-trio-select');
            [comboDuoSelect, comboTrioSelect].forEach(sel => sel.addEventListener('change', function() {
                buildComboBtn.disabled = !(comboDuoSelect.value && comboTrioSelect.value);
            }));
        }
    });

    // History tab rendering
    function renderHistoryTable() {
        const historyContent = document.getElementById('history-content');
        if (!historyContent) return;
        
        let html = '<table class="freq-table" style="width:100%;"><thead><tr><th>#</th><th>Numbers</th></tr></thead><tbody>';
        allMainDraws.forEach((nums, idx) => {
            html += `<tr><td>${idx+1}</td><td><div class="aligned-numbers">${nums.map((num, i) => `<span class='plain-number'>${num}</span>${i < nums.length - 1 ? '<b style=\"color:#000;font-size:1.2em;\">-</b>' : ''}`).join('')}</div></td></tr>`;
        });
        html += '</tbody></table>';
        historyContent.innerHTML = html;
    }

    // Function to analyze frequent sets and populate dropdowns
    function analyzeFrequentSets() {
        console.log('Starting analyzeFrequentSets...');
        // Analyze and track actual trios that appeared together in a single draw
        const actualTrios = new Map(); // Store actual trios from draws
        const pairCounts = new Map();
        const tripletCounts = new Map();
        console.log('Number of draws to analyze:', allMainDraws.length);
        
        // First pass: Collect all actual trios that appeared together
        const filteredDraws = allMainDraws.filter(d => d.year >= 2016 && d.year <= 2025);
        filteredDraws.forEach(drawObj => {
            const sortedDraw = [...drawObj.numbers].sort((a, b) => a - b);
            
            // Track all trios that actually appeared together in this draw
            for (let i = 0; i < sortedDraw.length - 2; i++) {
                for (let j = i + 1; j < sortedDraw.length - 1; j++) {
                    for (let k = j + 1; k < sortedDraw.length; k++) {
                        const trio = [sortedDraw[i], sortedDraw[j], sortedDraw[k]];
                        const trioKey = trio.join('-');
                        actualTrios.set(trioKey, true);
                    }
                }
            }
        });
        
        console.log('Found', actualTrios.size, 'unique trios that appeared in actual draws');
        
        // Second pass: Count frequencies of actual trios
        filteredDraws.forEach(drawObj => {
            const sortedDraw = [...drawObj.numbers].sort((a, b) => a - b);
            
            // Count pairs (for other functionality)
            for (let i = 0; i < sortedDraw.length; i++) {
                for (let j = i + 1; j < sortedDraw.length; j++) {
                    const pair = [sortedDraw[i], sortedDraw[j]];
                    const pairKey = pair.join('-');
                    pairCounts.set(pairKey, (pairCounts.get(pairKey) || 0) + 1);
                }
            }
            
            // Only count trios that we've seen in actual draws
            const seenTrios = new Set(); // Avoid counting same trio multiple times in one draw
            for (let i = 0; i < sortedDraw.length - 2; i++) {
                for (let j = i + 1; j < sortedDraw.length - 1; j++) {
                    for (let k = j + 1; k < sortedDraw.length; k++) {
                        const trio = [sortedDraw[i], sortedDraw[j], sortedDraw[k]];
                        const trioKey = trio.join('-');
                        if (actualTrios.has(trioKey) && !seenTrios.has(trioKey)) {
                            tripletCounts.set(trioKey, (tripletCounts.get(trioKey) || 0) + 1);
                            seenTrios.add(trioKey);
                        }
                    }
                }
            }
        });
        
        // Convert to arrays and sort by frequency (descending)
        const sortedPairs = Array.from(pairCounts.entries())
            .filter(([_, count]) => count >= 1)  // Include all actual pairs
            .sort((a, b) => b[1] - a[1]);
            
        // Only include trios that actually appeared together in a draw
        window.sortedTriplets = Array.from(tripletCounts.entries())
            .filter(([trioKey, count]) => actualTrios.has(trioKey) && count >= 1)  // Only actual trios that appeared at least once
            .sort((a, b) => b[1] - a[1]);
            
        console.log('Found', sortedPairs.length, 'frequent pairs and', window.sortedTriplets.length, 'frequent trios');
        
        // Populate duo select dropdowns with improved UI
        const duo1Select = document.getElementById('duo1-select');
        const duo2Select = document.getElementById('duo2-select');
        const comboDuoSelect = document.getElementById('combo-duo-select');
        const comboTrioSelect = document.getElementById('combo-trio-select');
        
        // Section 2: Populate duo dropdowns
        if (duo1Select && duo2Select) {
            duo1Select.innerHTML = '<option value="">Select First Duo</option>';
            duo2Select.innerHTML = '<option value="">Select Second Duo</option>';
            sortedPairs.forEach(([pairKey, count]) => {
                const option1 = document.createElement('option');
                option1.value = pairKey;
                option1.textContent = `${pairKey.replace(/-/g, ' - ')} (${count}×)`;
                option1.style.fontWeight = '700'; // Make numbers bolder
                duo1Select.appendChild(option1.cloneNode(true));
                duo2Select.appendChild(option1);
            });
            duo1Select.selectedIndex = -1;
            duo2Select.selectedIndex = -1; // No selection by default
        }
        // Section 3: Populate duo and trio dropdowns
        if (comboDuoSelect && comboTrioSelect) {
            comboDuoSelect.innerHTML = '<option value="">Select Duo</option>';
            comboTrioSelect.innerHTML = '<option value="">Select Trio</option>';
            sortedPairs.forEach(([pairKey, count]) => {
                const option = document.createElement('option');
                option.value = pairKey;
                option.textContent = `${pairKey.replace(/-/g, ' - ')} (${count}×)`;
                option.style.fontWeight = '700'; // Make numbers bolder
                comboDuoSelect.appendChild(option);
            });
            sortedTriplets.forEach(([trioKey, count]) => {
                const option = document.createElement('option');
                option.value = trioKey;
                option.textContent = `${trioKey.replace(/-/g, ' - ')} (${count}×)`;
                option.style.fontWeight = '700'; // Make numbers bolder
                comboTrioSelect.appendChild(option);
            });
            comboDuoSelect.selectedIndex = -1;
            comboTrioSelect.selectedIndex = -1; // No selection by default
        }
            // Initialize Choices.js on all dropdowns (only once)
        [duo1Select, duo2Select, comboDuoSelect, comboTrioSelect].forEach(sel => {
            if (sel && !sel.classList.contains('choices-initialized')) {
                // Create a simple select element without Choices.js
                sel.style.display = 'block';
                sel.style.width = '100%';
                sel.style.padding = '8px';
                sel.style.borderRadius = '4px';
                sel.style.border = '1px solid #ddd';
                sel.style.marginBottom = '10px';
                
                // Add search input above the select
                const searchContainer = document.createElement('div');
                searchContainer.style.marginBottom = '8px';
                
                const searchInput = document.createElement('input');
                searchInput.type = 'text';
                searchInput.placeholder = 'Search for a number...';
                searchInput.style.width = '100%';
                searchInput.style.padding = '8px';
                searchInput.style.border = '1px solid #ddd';
                searchInput.style.borderRadius = '4px';
                
                // Store original options
                const originalOptions = Array.from(sel.options);
                
                // Add event listener for search
                searchInput.addEventListener('input', function(e) {
                    const searchTerm = e.target.value.trim();
                    
                    // Clear current options
                    while (sel.options.length > 0) {
                        sel.remove(0);
                    }
                    
                    // Add default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = sel.getAttribute('data-placeholder') || 'Select an option';
                    sel.appendChild(defaultOption);
                    
                    // Filter and add matching options
                    if (searchTerm === '') {
                        // Show all options if search is empty
                        originalOptions.forEach(opt => {
                            if (opt.value !== '') {
                                sel.appendChild(opt.cloneNode(true));
                            }
                        });
                    } else if (/^\d+$/.test(searchTerm)) {
                        // Only filter if search term is a number
                        originalOptions.forEach(opt => {
                            if (opt.value === '') return;
                            
                            // Check if any number in the option matches exactly
                            const numbers = opt.value.split('-');
                            if (numbers.includes(searchTerm)) {
                                sel.appendChild(opt.cloneNode(true));
                            }
                        });
                    }
                    
                    // Trigger change event
                    const event = new Event('change');
                    sel.dispatchEvent(event);
                });
                
                // Add elements to the DOM
                searchContainer.appendChild(searchInput);
                sel.parentNode.insertBefore(searchContainer, sel);
                sel.classList.add('choices-initialized');
            }
        });
        // Add a count of available pairs
        const pairCountElement = document.createElement('div');
            pairCountElement.style.fontSize = '0.9em';
            pairCountElement.style.color = '#4a5568';
            pairCountElement.style.marginTop = '8px';
            pairCountElement.textContent = `Showing ${sortedPairs.length} frequent pairs (appearing 2+ times)`;
            duo1Select.parentNode.insertBefore(pairCountElement, duo1Select.nextSibling);
            // Enable the build button when both duos are selected
            const buildDuoBtn = document.getElementById('build-duo-combo-btn');
            if (buildDuoBtn) {
                const updateBuildButtonState = () => {
                    buildDuoBtn.disabled = !(duo1Select.value && duo2Select.value);
                };
                duo1Select.addEventListener('change', updateBuildButtonState);
                duo2Select.addEventListener('change', updateBuildButtonState);
            }
        }
    
    </script>
    <script>
    // Defer non-critical JavaScript loading
    document.addEventListener('DOMContentLoaded', function() {
        // Load Choices.js after the page is interactive
        const choicesScript = document.createElement('script');
        choicesScript.src = 'https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js';
        choicesScript.onload = function() {
            console.log('Choices.js loaded');
            // Initialize any Choices.js instances here if needed
        };
        document.body.appendChild(choicesScript);

        // Optimize touch interactions
        document.documentElement.style.touchAction = 'manipulation';
        
        // Add passive event listeners for better scrolling performance
        const addPassiveEventListener = (element, event, handler) => {
            const supportsPassive = false;
            try {
                const opts = Object.defineProperty({}, 'passive', {
                    get: function() { supportsPassive = true; }
                });
                window.addEventListener('test', null, opts);
                window.removeEventListener('test', null, opts);
            } catch (e) {}
            
            element.addEventListener(event, handler, supportsPassive ? { passive: true } : false);
        };

        // Optimize window resize
        let resizeTimeout;
        addPassiveEventListener(window, 'resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                // Handle resize logic here if needed
            }, 250);
        });

        // Optimize scroll performance
        addPassiveEventListener(window, 'scroll', function() {
            // Handle scroll logic here if needed
        }, { passive: true });

        // Optimize button clicks for mobile
        document.querySelectorAll('button, a, [role="button"]').forEach(button => {
            button.style.webkitTapHighlightColor = 'transparent';
            button.addEventListener('touchstart', function() {
                this.classList.add('active');
            }, { passive: true });
            button.addEventListener('touchend', function() {
                this.classList.remove('active');
            }, { passive: true });
        });
    });

    // Optimize animation frame usage
    (function() {
        let lastScrollTop = 0;
        const delta = 5;
        
        function checkScroll() {
            const st = window.scrollY;
            
            if (Math.abs(lastScrollTop - st) <= delta) {
                return; // No significant scroll
            }
            
            // Handle scroll direction
            if (st > lastScrollTop && st > 0) {
                // Scrolling down
            } else {
                // Scrolling up
            }
            
            lastScrollTop = st <= 0 ? 0 : st;
        }
        
        // Throttle the scroll event
        let ticking = false;
        window.addEventListener('scroll', function() {
            if (!ticking) {
                window.requestAnimationFrame(function() {
                    checkScroll();
                    ticking = false;
                });
                ticking = true;
            }
        }, { passive: true });
    })();
    </script>
</body>
</html>