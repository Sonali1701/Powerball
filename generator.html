<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Choices.js for searchable dropdowns - Load with preconnect and preload -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js" as="script">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css" media="print" onload="this.media='all'">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, viewport-fit=cover">
    <meta name="theme-color" content="#3498db">
    <title>PowerBall Random Generator</title>
    <link rel="stylesheet" href="style.css" media="print" onload="this.media='all'">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <style>
      body {
        background: linear-gradient(120deg, #f0f4ff 0%, #fff 100%);
      }
      .generator-container {
        max-width: 900px;
        margin: 20px auto;
        background: #fff;
        border-radius: 16px;
        box-shadow: 0 4px 24px rgba(44,62,80,0.10);
        padding: 24px 16px;
        transition: all 0.3s ease;
        will-change: transform, box-shadow;
      }
      .generator-title {
        text-align: center;
        font-size: 2.1em;
        font-weight: 700;
        color: #234;
        margin-bottom: 18px;
        letter-spacing: 0.5px;
      }
      .generator-flex-layout {
        display: flex;
        flex-wrap: wrap;
        gap: 32px 24px;
        justify-content: center;
      }
      .generator-section {
        flex: 1 1 320px;
        min-width: 320px;
        max-width: 420px;
        margin-bottom: 0;
      }
      .generator-panel {
        background: #f8faff;
        border-radius: 14px;
        box-shadow: 0 2px 8px rgba(44,62,80,0.04);
        padding: 24px 18px 18px 18px;
        margin-bottom: 0;
      }
      .generator-panel h2 {
        font-size: 1.25em;
        font-weight: 600;
        color: #3498db;
        margin-bottom: 16px;
      }
      .multi-gen-btn, .freq-gen-btn, #build-duo-combo-btn, #build-combo-btn {
        background: linear-gradient(90deg, #3498db 0%, #6dd5fa 100%);
        color: #fff;
        border: none;
        border-radius: 8px;
        padding: 12px 18px;
        font-size: 1.08em;
        font-weight: 600;
        margin: 0 0 12px 0;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(44,62,80,0.08);
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
        min-height: 44px; /* Minimum touch target size */
        width: 100%;
        display: block;
      }
      .multi-gen-btn:hover, .freq-gen-btn:hover, #build-duo-combo-btn:hover, #build-combo-btn:hover {
        background: linear-gradient(90deg, #217dbb 0%, #3498db 100%);
        box-shadow: 0 4px 16px rgba(44,62,80,0.13);
      }
      /* Mobile-first responsive design */
      @media (max-width: 480px) {
        .generator-container {
          padding: 8px 4px 16px 4px;
          margin: 16px 8px;
          width: calc(100% - 24px);
          box-sizing: border-box;
        }
        .generator-title {
          font-size: 1.6em;
          padding: 0 8px;
        }
        .tab-nav {
          flex-wrap: wrap;
          padding: 6px 4px;
          gap: 6px;
        }
        .tab-btn {
          padding: 8px 12px;
          font-size: 1em;
          flex: 1 0 calc(50% - 12px);
          text-align: center;
        }
        .generator-panel {
          padding: 16px 12px;
          margin: 0 4px;
          width: calc(100% - 32px);
        }
        .multi-gen-btn, .freq-gen-btn, #build-duo-combo-btn, #build-combo-btn {
          width: 100%;
          margin: 0 0 10px 0;
          padding: 12px;
          font-size: 1.1em;
        }
        .pills-container {
          grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
          gap: 8px;
        }
      }

      @media (min-width: 481px) and (max-width: 768px) {
        .generator-container {
          padding: 16px 12px;
          margin: 20px 12px;
          width: calc(100% - 48px);
        }
        .generator-title {
          font-size: 1.8em;
        }
        .tab-btn {
          padding: 8px 14px;
          font-size: 1.05em;
        }
      }

      @media (min-width: 769px) {
        .generator-container {
          max-width: 900px;
          margin: 40px auto;
          padding: 32px 18px;
        }
      }
      .back-link {
        display: block;
        margin: 32px auto 0 auto;
        color: #3498db;
        font-weight: 600;
        text-decoration: none;
        text-align: center;
        width: 100%;
        font-size: 1.08em;
      }
      .tab-nav {
        display: flex;
        justify-content: center;
        gap: 0 18px;
        margin-bottom: 24px;
        background: #f8faff;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(44,62,80,0.04);
        padding: 10px 0;
      }
      .tab-btn {
        background: none;
        border: none;
        color: #234;
        font-size: 1.08em;
        font-weight: 600;
        padding: 8px 18px;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.13s, color 0.13s;
      }
      .tab-btn.active {
        background: linear-gradient(90deg, #3498db 0%, #6dd5fa 100%);
        color: #fff;
      }
      .tab-btn:not(.active):hover {
        background: #eaf3fb;
        color: #3498db;
      }
      /* Make all balls bold throughout the page */
      .generated-ball, .red-ball, .ball, .yellow-ball {
        font-weight: bold !important;
      }
      /* Make selection pills more visually clear */
      .pill-btn.selected {
        background: linear-gradient(90deg, #ffe066 0%, #e67e22 100%) !important;
        color: #222 !important;
        border: 2px solid #e67e22 !important;
        box-shadow: 0 0 0 3px #ffe06699, 0 2px 8px rgba(230, 126, 34, 0.13);
        font-weight: bold;
        outline: none;
      }
      /* Enhanced Section 2: Create Combination from 2 Duos */
      #duo-builder-panel {
        background: #f4faff;
        border-radius: 16px;
        box-shadow: 0 2px 12px rgba(52,152,219,0.08);
        padding: 28px 22px 22px 22px;
        margin-bottom: 0;
        max-width: 420px;
        margin-left: auto;
        margin-right: auto;
      }
      #duo-builder-panel h2 {
        color: #217dbb;
        font-size: 1.22em;
        font-weight: 700;
        margin-bottom: 18px;
        letter-spacing: 0.5px;
      }
      .duo-select-label {
        font-size: 1.07em;
        font-weight: 600;
        color: #234;
        margin-bottom: 6px;
        display: block;
      }
      .duo-select {
        width: 100%;
        padding: 10px 12px;
        border-radius: 8px;
        border: 1.5px solid #b3d6f2;
        font-size: 1.08em;
        margin-bottom: 16px;
        background: #fff;
        transition: border 0.15s;
      }
      .duo-select:focus {
        border: 1.5px solid #3498db;
        outline: none;
      }
      #build-duo-combo-btn {
        width: 100%;
        font-size: 1.13em;
        padding: 12px 0;
        border-radius: 10px;
        margin-top: 10px;
        margin-bottom: 0;
      }
      #built-duo-combo-result {
        margin-top: 22px !important;
        background: #eaf6fb;
        border-radius: 10px;
        padding: 18px 12px;
        min-height: 36px;
        font-size: 1.09em;
        color: #234;
        box-shadow: 0 1px 4px rgba(52,152,219,0.07);
      }
      /* Pills container styling */
      /* Enhanced Pills Container */
      .pills-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 10px;
        margin: 12px 0 20px 0;
      }
      
      /* Pill Buttons */
      .pill-btn {
        background: #f0f7ff;
        border: 1px solid #d0e3ff;
        border-radius: 8px;
        padding: 8px 12px;
        font-size: 0.95em;
        color: #2c5282;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      
      .pill-btn:hover {
        background: #e1f0ff;
        transform: translateY(-1px);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      }
      
      .pill-btn.selected {
        background: #3182ce;
        color: white;
        border-color: #2c5282;
        font-weight: 600;
      }
      
      /* Section Headers */
      .section-header {
        font-size: 1.1em;
        font-weight: 600;
        color: #2d3748;
        margin: 20px 0 12px 0;
        padding-bottom: 8px;
        border-bottom: 2px solid #e2e8f0;
      }
      
      /* Frequency Badge */
      .frequency-badge {
        display: inline-block;
        background: #ebf8ff;
        color: #2b6cb0;
        font-size: 0.8em;
        padding: 2px 6px;
        border-radius: 10px;
        margin-left: 6px;
        font-weight: 600;
      }
      
      /* Responsive adjustments */
      @media (max-width: 768px) {
        .pills-container {
          grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        }
      }
      
      @media (max-width: 480px) {
        .pills-container {
          grid-template-columns: repeat(2, 1fr);
        }
      }
      
      /* Pill button styling */
      .pill-btn {
        background: #f0f7ff;
        border: 1.5px solid #cce0f7;
        border-radius: 16px;
        padding: 8px 14px;
        font-size: 0.95em;
        font-weight: 500;
        color: #2c3e50;
        cursor: pointer;
        transition: all 0.15s ease;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      }
      
      .pill-btn:hover {
        background: #e1f0ff;
        transform: translateY(-1px);
        box-shadow: 0 3px 8px rgba(0,0,0,0.08);
      }
      
      .pill-btn.selected {
        background: linear-gradient(135deg, #4a90e2 0%, #5ab0f4 100%);
        color: white;
        border-color: #3a7bc8;
        font-weight: 600;
        box-shadow: 0 2px 6px rgba(74, 144, 226, 0.25);
      }
      
      /* Section 3: Create Combination from 1 Duo and 1 Trio */
      #combo-builder-panel {
        background: #f9fcff;
        border-radius: 16px;
        box-shadow: 0 2px 12px rgba(74, 144, 226, 0.08);
        padding: 28px 22px 22px 22px;
        margin-top: 24px;
      }
      
      #combo-builder-panel h2 {
        color: #2c6aa0;
        font-size: 1.22em;
        font-weight: 700;
        margin-bottom: 18px;
        letter-spacing: 0.5px;
      }
      
      /* 2x Results Modern Style */
      .twox-combo-results-list {
        margin-top: 18px;
        background: #f8faff;
        border-radius: 14px;
        box-shadow: 0 2px 8px rgba(44,62,80,0.06);
        padding: 18px 14px 10px 14px;
        max-width: 480px;
        margin-left: auto;
        margin-right: auto;
      }
      .twox-combo-row {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 1.13em;
        margin-bottom: 10px;
        padding-bottom: 6px;
        border-bottom: 1px solid #e3eaf2;
      }
      .twox-combo-row:last-child {
        border-bottom: none;
      }
      .twox-combo-label {
        font-weight: 600;
        color: #217dbb;
        min-width: 140px;
        display: inline-block;
      }
      .twox-red-ball {
        display: inline-block;
        background: linear-gradient(120deg, #e74c3c 60%, #ffb3b3 100%);
        color: #fff;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        line-height: 32px;
        text-align: center;
        font-size: 1.08em;
        font-weight: bold;
        margin-right: 4px;
        box-shadow: 0 2px 8px rgba(231,76,60,0.10);
        border: 2px solid #e74c3c;
      }
      /* 2x Sets Interactive Panel and Results */
      #twox-interactive-panel {
        background: #f8faff;
        border-radius: 16px;
        box-shadow: 0 2px 12px rgba(52,152,219,0.08);
        padding: 24px 18px 18px 18px;
        margin-bottom: 24px;
        max-width: 480px;
        margin-left: auto;
        margin-right: auto;
      }
      #twox-ball-select {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 18px;
        justify-content: center;
      }
      .twox-ball {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: #fff;
        border: 2px solid #e74c3c;
        color: #e74c3c;
        font-weight: bold;
        font-size: 1.08em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.15s, color 0.15s, border 0.15s;
      }
      .twox-ball.selected {
        background: #e74c3c;
        color: #fff;
        border: 2px solid #c0392b;
        box-shadow: 0 2px 8px rgba(231,76,60,0.13);
      }
      #twox-results-panel {
        background: #f4faff;
        border-radius: 14px;
        box-shadow: 0 2px 8px rgba(52,152,219,0.07);
        padding: 18px 14px;
        margin-top: 18px;
        min-height: 60px;
      }
      .twox-combo-row {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 1.13em;
        margin-bottom: 10px;
        padding-bottom: 6px;
        border-bottom: 1px solid #e3eaf2;
      }
      .twox-combo-row:last-child {
        border-bottom: none;
      }
      .twox-combo-label {
        font-weight: 600;
        color: #217dbb;
        min-width: 170px;
        display: inline-block;
      }
      .twox-red-ball {
        display: inline-block;
        background: linear-gradient(120deg, #e74c3c 60%, #ffb3b3 100%);
        color: #fff;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        line-height: 32px;
        text-align: center;
        font-size: 1.08em;
        font-weight: bold;
        margin-right: 4px;
        box-shadow: 0 2px 8px rgba(231,76,60,0.10);
        border: 2px solid #e74c3c;
      }
    </style>
</head>
<body>
    <div class="generator-container">
      <div class="generator-title">Random Number Generator</div>
      <nav class="tab-nav">
        <button class="tab-btn" data-tab="home">Quick Generator</button>
      </nav>
      <div id="home-tab" class="tab-content" style="display:block;">
      </div>
      <div id="history-tab" class="tab-content" style="display:none;">
        <div id="history-content"></div>
      </div>
      <div class="generator-flex-layout">
          <!-- Section 1: Quick Random Generator -->
          <section class="generator-section">
            <div class="generator-panel">
              <h2>1. Quick Random Generator</h2>
              <div style="margin-bottom: 18px;">
                <button id="generate-from-trios" class="multi-gen-btn" style="background: #9b59b6; color: white; margin-bottom: 8px;">From Frequent Trios</button>
                <button id="generate-from-overlapping-trios" class="multi-gen-btn" style="background: #e74c3c; color: white; margin-bottom: 8px;">From Overlapping Trios</button>
                <button id="generate-enhanced-trios" class="multi-gen-btn" style="background: #27ae60; color: white;">Enhanced Trio Generator</button>
              </div>
              <div id="generated-table" style="margin-top:18px; min-height: 200px; border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.05);"></div>
              <div id="csv-loading" style="margin-top:10px; color:#888; font-size:1.05em;"></div>
              <div style="margin-top:18px; color:#888; font-size:1.05em;">Each combination: 5 unique numbers (1-69).</div>
            </div>
          </section>
          <!-- Section 2: Create Combination from 2 Duos (Enhanced) -->
          <section class="generator-section">
            <div class="generator-panel" id="duo-builder-panel" style="background: linear-gradient(135deg, #f8faff 0%, #f0f7ff 100%); border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05);">
              <h2 style="color: #2c3e50; font-size: 1.3em; margin: 0 0 18px 0; padding-bottom: 10px; border-bottom: 2px solid #e0e6ed; display: flex; align-items: center;">
                <i class="fas fa-random" style="margin-right: 10px; color: #3498db;"></i>
                2. Create Combination from 2 Duos
              </h2>
              
              <div class="search-container" style="margin-bottom: 20px;">
                <div style="position: relative; margin-bottom: 15px;">
                  <label for="duo1-select" class="search-label">Select Duo 1:</label>
                  <div class="custom-select" style="position: relative;">
                    <select id="duo1-select" class="enhanced-select" style="width: 100%; padding: 12px 40px 12px 15px; font-size: 1.1em; font-weight: bold; border: 2px solid #d1d8e0; border-radius: 8px; background-color: white; appearance: none; -webkit-appearance: none; -moz-appearance: none; cursor: pointer; transition: all 0.2s ease;" onfocus="this.style.borderColor='#3498db'; this.style.boxShadow='0 0 0 3px rgba(52, 152, 219, 0.2)';" onblur="this.style.borderColor='#d1d8e0'; this.style.boxShadow='none';">
                      <option value="">Search or select a duo...</option>
                    </select>
                    <div class="select-arrow" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); pointer-events: none; color: #7f8c8d;">
                      <i class="fas fa-chevron-down"></i>
                    </div>
                  </div>
                </div>
                
                <div style="position: relative; margin-bottom: 20px;">
                  <label for="duo2-select" class="search-label">Select Duo 2:</label>
                  <div class="custom-select" style="position: relative;">
                    <select id="duo2-select" class="enhanced-select" style="width: 100%; padding: 12px 40px 12px 15px; font-size: 1.1em; font-weight: bold; border: 2px solid #d1d8e0; border-radius: 8px; background-color: white; appearance: none; -webkit-appearance: none; -moz-appearance: none; cursor: pointer; transition: all 0.2s ease;" onfocus="this.style.borderColor='#3498db'; this.style.boxShadow='0 0 0 3px rgba(52, 152, 219, 0.2)';" onblur="this.style.borderColor='#d1d8e0'; this.style.boxShadow='none';">
                      <option value="">Search or select a duo...</option>
                    </select>
                    <div class="select-arrow" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); pointer-events: none; color: #7f8c8d;">
                      <i class="fas fa-chevron-down"></i>
                    </div>
                  </div>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 5px;">
                  <button id="build-duo-combo-btn" class="action-btn" style="flex: 1; background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);" disabled>
                    <i class="fas fa-magic"></i> Generate Combo
                  </button>
                  <button id="clear-duo-selection-btn" class="action-btn" style="flex: 0 0 auto; background: #e74c3c; color: white;" title="Clear selection">
                    <i class="fas fa-times"></i> Clear
                  </button>
                </div>
              </div>
              
              <div id="built-duo-combo-result" style="margin-top: 15px; padding: 15px; background: white; border-radius: 8px; border: 1px solid #e0e6ed; min-height: 60px; display: flex; align-items: center; justify-content: center; font-size: 1.1em; color: #7f8c8d;">
                Your generated combinations will appear here
              </div>
            </div>
          </section>
          
          <!-- Section 3: Create Combination from 1 Duo and 1 Trio (Enhanced) -->
          <section class="generator-section">
            <div class="generator-panel" id="combo-builder-panel" style="background: linear-gradient(135deg, #f8faff 0%, #f0f7ff 100%); border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.05);">
              <h2 style="color: #2c3e50; font-size: 1.3em; margin: 0 0 18px 0; padding-bottom: 10px; border-bottom: 2px solid #e0e6ed; display: flex; align-items: center;">
                <i class="fas fa-random" style="margin-right: 10px; color: #9b59b6;"></i>
                3. Create Combination from Duo + Trio
              </h2>
              
              <div class="search-container" style="margin-bottom: 20px;">
                <div style="position: relative; margin-bottom: 15px;">
                  <label for="combo-duo-select" class="search-label">Select Duo:</label>
                  <div class="custom-select" style="position: relative;">
                    <select id="combo-duo-select" class="enhanced-select" style="width: 100%; padding: 12px 40px 12px 15px; font-size: 1.1em; font-weight: bold; border: 2px solid #d1d8e0; border-radius: 8px; background-color: white; appearance: none; -webkit-appearance: none; -moz-appearance: none; cursor: pointer; transition: all 0.2s ease;" onfocus="this.style.borderColor='#9b59b6'; this.style.boxShadow='0 0 0 3px rgba(155, 89, 182, 0.2)';" onblur="this.style.borderColor='#d1d8e0'; this.style.boxShadow='none';">
                      <option value="">Search or select a duo...</option>
                    </select>
                    <div class="select-arrow" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); pointer-events: none; color: #7f8c8d;">
                      <i class="fas fa-chevron-down"></i>
                    </div>
                  </div>
                </div>
                
                <div style="position: relative; margin-bottom: 20px;">
                  <label for="combo-trio-select" class="search-label">Select Trio:</label>
                  <div class="custom-select" style="position: relative;">
                    <select id="combo-trio-select" class="enhanced-select" style="width: 100%; padding: 12px 40px 12px 15px; font-size: 1.1em; font-weight: bold; border: 2px solid #d1d8e0; border-radius: 8px; background-color: white; appearance: none; -webkit-appearance: none; -moz-appearance: none; cursor: pointer; transition: all 0.2s ease;" onfocus="this.style.borderColor='#9b59b6'; this.style.boxShadow='0 0 0 3px rgba(155, 89, 182, 0.2)';" onblur="this.style.borderColor='#d1d8e0'; this.style.boxShadow='none';">
                      <option value="">Search or select a trio...</option>
                    </select>
                    <div class="select-arrow" style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); pointer-events: none; color: #7f8c8d;">
                      <i class="fas fa-chevron-down"></i>
                    </div>
                  </div>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 5px;">
                  <button id="build-combo-btn" class="action-btn" style="flex: 1; background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);" disabled>
                    <i class="fas fa-magic"></i> Generate Combo
                  </button>
                  <button id="clear-combo-selection-btn" class="action-btn" style="flex: 0 0 auto; background: #e74c3c; color: white;" title="Clear selection">
                    <i class="fas fa-times"></i> Clear
                  </button>
                </div>
              </div>
              
              <div id="built-combo-result" style="margin-top: 15px; padding: 15px; background: white; border-radius: 8px; border: 1px solid #e0e6ed; min-height: 60px; display: flex; align-items: center; justify-content: center; font-size: 1.1em; color: #7f8c8d;">
                Your generated combinations will appear here
              </div>
            </div>
          </section>
        </div>

        <a href="index.html" class="back-link">&larr; Back to Main</a>
      </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
    let historicalCombos = [];
    let allMainDraws = [];
    const csvLoading = document.getElementById('csv-loading');
    // Load and parse the CSV file
    csvLoading.textContent = 'Loading historical Powerball data...';
    fetch('powerball.csv')
        .then(response => response.text())
        .then(rawCsv => {
            // Clean the CSV: remove all quotes, trim spaces, standardize header
            let lines = rawCsv.split('\n').map(line => line.replace(/"/g, '').trim());
            if (lines[0].toLowerCase().includes('date') && lines[0].toLowerCase().includes('winning numbers')) {
                lines[0] = 'Date,Winning Numbers,Powerball,PowerPlay';
            }
            lines = lines.map(line => line.split(',').map(f => f.trim()).join(','));
            const cleanedCsv = lines.join('\n');
            Papa.parse(cleanedCsv, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    const data = results.data;
                    // Extract all main draw combinations
                    historicalCombos = [];
                    allMainDraws = [];
                    for (let i = 0; i < data.length; i++) {
                        const row = data[i];
                        const dateStr = (row.Date || '').trim();
                        const parts = dateStr.split('/');
                        const year = parts.length === 3 ? parseInt(parts[2], 10) : 0;
                        // Main draw row
                        if (row.Date && year >= 2016 && row['Winning Numbers'] && row['Winning Numbers'].toLowerCase().includes('powerball')) {
                            let winNumbers = row['Winning Numbers'].replace(/®/g, '').replace(/Powerball.*Numbers\s*/i, '').trim();
                            let mainArr = winNumbers.split(' - ').map(x => parseInt(x.trim(), 10)).filter(n => n >= 1 && n <= 69);
                            if (mainArr.length === 5) {
                                const drawDate = row.Date ? new Date(row.Date).toLocaleDateString() : 'Unknown date';
                                historicalCombos.push({
                                    combo: mainArr.slice().sort((a,b)=>a-b).join('-')
                                });
                                allMainDraws.push({ 
                                    arr: mainArr, 
                                    year,
                                    date: drawDate
                                });
                            }
                            // Check next row for Double Play
                            if (i + 1 < data.length) {
                                const nextRow = data[i + 1];
                                if (!nextRow.Date && nextRow['Winning Numbers'] && nextRow['Winning Numbers'].toLowerCase().includes('double play')) {
                                    let doubleNumbers = nextRow['Winning Numbers'].replace(/®/g, '').replace(/Double Play.*Numbers\s*/i, '').trim();
                                    let doubleArr = doubleNumbers.split(' - ').map(x => parseInt(x.trim(), 10)).filter(n => n >= 1 && n <= 69);
                                    if (doubleArr.length === 5) {
                                        const drawDate = nextRow.Date ? new Date(nextRow.Date).toLocaleDateString() : 'Unknown date';
                                        allMainDraws.push({ 
                                            arr: doubleArr, 
                                            year,
                                            date: drawDate + ' (Double Play)'
                                        });
                                    }
                                }
                            }
                        }
                    }
                    csvLoading.textContent = '';
                    console.log('CSV data loaded, analyzing frequent sets...');
                    // Now analyze frequent sets
                    analyzeFrequentSets();
                    console.log('Frequent sets analysis complete');
                },
                error: function(error) {
                    console.log('Error parsing CSV:', error);
                }
            });
        });
    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function generateUniqueNumbers(count, min, max, exclude=[]) {
        const nums = [];
        while (nums.length < count) {
            const num = Math.floor(Math.random() * (max - min + 1)) + min;
            if (!nums.includes(num) && !exclude.includes(num)) {
                nums.push(num);
            }
        }
        return nums.sort((a, b) => a - b);
    }

    function generateCombination() {
        const mainNumbers = generateUniqueNumbers(5, 1, 69);
        return { mainNumbers };
    }
    function countComboInHistory(whiteBalls) {
        const key = whiteBalls.slice().sort((a,b)=>a-b).join('-');
        return historicalCombos.filter(h => h.combo === key).length;
    }
    function generateFromFrequentTrios() {
        console.log('generateFromFrequentTrios called');
        console.log('window.sortedTriplets:', window.sortedTriplets);
        
        if (!window.sortedTriplets || window.sortedTriplets.length === 0) {
            console.error('No sortedTriplets data available');
            alert('Loading frequent trios data... Please try again in a moment.');
            return [1, 2, 3, 4, 5]; // Return a default set for testing
        }
        
        try {
            // Get top 10 most frequent trios
            const topTrios = window.sortedTriplets.slice(0, 10);
            console.log('Top 10 trios:', topTrios);
            
            if (topTrios.length === 0) {
                console.error('No trios available in topTrios');
                return [1, 2, 3, 4, 5]; // Return a default set for testing
            }
            
            const selectedTrio = topTrios[Math.floor(Math.random() * topTrios.length)];
            console.log('Selected trio:', selectedTrio);
            
            if (!selectedTrio || !selectedTrio[0]) {
                console.error('Invalid selectedTrio:', selectedTrio);
                return [1, 2, 3, 4, 5]; // Return a default set for testing
            }
            
            const [n1, n2, n3] = selectedTrio[0].split('-').map(Number);
            
            // Generate 2 more unique numbers not in the trio
            const exclude = [n1, n2, n3];
            const additionalNumbers = generateUniqueNumbers(2, 1, 69, exclude);
            
            const combination = [...[n1, n2, n3], ...additionalNumbers].sort((a, b) => a - b);
            console.log('Generated combination:', combination);
            return {
                combination: combination,
                basedOnTrio: `${n1}-${n2}-${n3}`
            };
        } catch (error) {
            console.error('Error in generateFromFrequentTrios:', error);
            return [1, 2, 3, 4, 5]; // Return a default set if there's an error
        }
    }
    
    // Track used trios for round-robin
    let usedTrioIndices = new Set();
    let lastUsedTrioIndex = -1;
    
    function generateFromOverlappingTrios() {
        console.log('generateFromOverlappingTrios called');
        
        if (!window.sortedTriplets || window.sortedTriplets.length < 2) {
            console.error('Not enough trios available');
            alert('Not enough valid trios found in the data. Try with a larger date range or different settings.');
            return { combination: [1, 2, 3, 4, 5], basedOnTrio: 'Default (not enough valid trios)', isOverlap: false };
        }
        
        try {
            // 1. Get all trios regardless of frequency
            const validTrios = [...window.sortedTriplets];
            
            if (validTrios.length < 2) {
                console.log('Not enough trios available, using all available trios');
                validTrios.push(...window.sortedTriplets);
            }
            
            // Reset used indices if we've used all trios
            if (usedTrioIndices.size >= validTrios.length) {
                console.log('Resetting used trios for round-robin');
                usedTrioIndices.clear();
            }
        
            console.log('Using', validTrios.length, 'valid trios for overlapping');
            
            let selectedTrios = [];
            let commonNumbers = [];
            const maxAttempts = 200;
            let attempts = 0;
            let foundMatch = false;
            
            // Strategy 1: Find one full trio that shares one number with another trio
            while (attempts < maxAttempts && !foundMatch) {
                // Pick a random trio that hasn't been used recently
                let baseTrioIndex;
                do {
                    baseTrioIndex = Math.floor(Math.random() * validTrios.length);
                } while (usedTrioIndices.has(baseTrioIndex) && attempts++ < maxAttempts);
                
                if (attempts >= maxAttempts) break;
                
                const baseTrio = validTrios[baseTrioIndex];
                const baseNums = baseTrio[0].split('-').map(Number);
                
                // Find another trio that shares exactly one number with the base trio
                for (let i = 0; i < validTrios.length; i++) {
                    if (i === baseTrioIndex) continue;
                    
                    const otherTrio = validTrios[i];
                    const otherNums = otherTrio[0].split('-').map(Number);
                    
                    // Find common numbers
                    const common = baseNums.filter(num => otherNums.includes(num));
                    
                    // If they share exactly one number
                    if (common.length === 1) {
                        // Use the full base trio and the other two numbers from the other trio
                        const otherTwoNums = otherNums.filter(num => !baseNums.includes(num));
                        // Ensure we use all base numbers plus additional unique numbers
                        const combination = [...new Set([...baseNums, ...otherTwoNums])].slice(0, 5);
                        
                        // Make sure all base numbers are included
                        const missingBaseNums = baseNums.filter(num => !combination.includes(num));
                        if (missingBaseNums.length > 0) {
                            // Replace some numbers to include missing base numbers
                            combination.splice(-missingBaseNums.length, missingBaseNums.length, ...missingBaseNums);
                        }
                        
                        // Mark this trio as used
                        usedTrioIndices.add(baseTrioIndex);
                        lastUsedTrioIndex = baseTrioIndex;
                        
                        return {
                            combination: [...combination].sort((a, b) => a - b),
                            basedOnTrio: `Base: ${baseTrio[0]}, Shared: ${common[0]}`,
                            isOverlap: true
                        };
                    }
                }
                
                attempts++;
            }
            
            // Strategy 2: Find one trio that shares numbers with two other trios
            attempts = 0;
            while (attempts < maxAttempts / 2 && !foundMatch) {
                // Pick a random trio that hasn't been used recently
                let baseTrioIndex;
                do {
                    baseTrioIndex = Math.floor(Math.random() * validTrios.length);
                } while (usedTrioIndices.has(baseTrioIndex) && attempts++ < maxAttempts);
                
                if (attempts >= maxAttempts) break;
                
                const baseTrio = validTrios[baseTrioIndex];
                const baseNums = baseTrio[0].split('-').map(Number);
                
                // Find two other trios that each share a number with the base trio
                for (let i = 0; i < validTrios.length && !foundMatch; i++) {
                    if (i === baseTrioIndex) continue;
                    
                    const trio1 = validTrios[i];
                    const nums1 = trio1[0].split('-').map(Number);
                    const common1 = baseNums.filter(num => nums1.includes(num));
                    
                    if (common1.length === 1) {
                        // Look for a second trio that shares a different number
                        for (let j = i + 1; j < validTrios.length; j++) {
                            if (j === baseTrioIndex) continue;
                            
                            const trio2 = validTrios[j];
                            const nums2 = trio2[0].split('-').map(Number);
                            const common2 = baseNums.filter(num => nums2.includes(num));
                            
                            // Make sure we're not using the same number as the first common
                            if (common2.length === 1 && common2[0] !== common1[0]) {
                                // Get the unique numbers from all three trios
                                const allNums = [...new Set([...baseNums, ...nums1, ...nums2])];
                                
                                if (allNums.length <= 5) {
                                    // Mark this trio as used
                                    usedTrioIndices.add(baseTrioIndex);
                                    lastUsedTrioIndex = baseTrioIndex;
                                    
                                    return {
                                        combination: allNums,
                                        basedOnTrio: `Base: ${baseTrio[0]}, Shared: ${common1[0]},${common2[0]}`,
                                        isOverlap: true
                                    };
                                }
                            }
                        }
                    }
                }
                
                attempts++;
            }
            
            // Fallback: If no good matches found, use any two trios with one common number
            console.log('No optimal trio matches found, falling back to simple overlap');
            for (let i = 0; i < validTrios.length; i++) {
                const nums1 = validTrios[i][0].split('-').map(Number);
                
                for (let j = i + 1; j < validTrios.length; j++) {
                    const nums2 = validTrios[j][0].split('-').map(Number);
                    const common = nums1.filter(num => nums2.includes(num));
                    
                    if (common.length > 0) {
                        // Use the first trio and one number from the second trio
                        const extraNumber = nums2.find(num => !nums1.includes(num)) || nums2[0];
                        const combination = [...nums1, extraNumber].slice(0, 5);
                        
                        // Mark this trio as used
                        usedTrioIndices.add(i);
                        lastUsedTrioIndex = i;
                        
                        return {
                            combination,
                            basedOnTrio: `Base: ${validTrios[i][0]}, Extra: ${extraNumber}`,
                            isOverlap: true
                        };
                    }
                }
            }
            
            // 3. Generate the final combination
            let combination;
            let basedOnTrio = '';
            
            // Get all unique numbers from selected trios
            const allNumbers = [...new Set(selectedTrios.flatMap(trio => 
                trio[0].split('-').map(Number)
            ))];
            
            if (allNumbers.length <= 5) {
                // If we have 5 or fewer unique numbers, use them all
                combination = allNumbers;
            } else {
                // Otherwise, prioritize the most common numbers
                const numberFrequencies = {};
                selectedTrios.forEach(trio => {
                    const nums = trio[0].split('-').map(Number);
                    nums.forEach(num => {
                        numberFrequencies[num] = (numberFrequencies[num] || 0) + 1;
                    });
                });
                
                // Sort numbers by frequency (descending) and take top 5
                combination = Object.entries(numberFrequencies)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .map(([num]) => parseInt(num, 10));
            }
            
            // Fill in with random numbers if needed
            if (combination.length < 5) {
                const exclude = [...combination];
                const additional = generateUniqueNumbers(5 - combination.length, 1, 69, exclude);
                combination = [...combination, ...additional];
            }
            
            // Sort the final combination
            combination = combination.slice(0, 5).sort((a, b) => a - b);
            
            // Create the description
            basedOnTrio = selectedTrios.map(trio => {
                const [nums, freq] = trio;
                return `Trio (${freq}x): ${nums}`;
            }).join(' & ');
            
            if (commonNumbers.length > 0) {
                basedOnTrio += ` (${commonNumbers.length} common)`;
            }
            
            return {
                combination,
                basedOnTrio,
                isOverlap: true,
                frequency: Math.min(...selectedTrios.map(t => t[1]))
            };
            
        } catch (error) {
            console.error('Error in generateFromOverlappingTrios:', error);
            // Fallback to regular trio generation on error
            return generateFromFrequentTrios();
        }
    }
    
    function renderCombinations(n, useFrequentTrios = false, useOverlappingTrios = false) {
        // Ensure n is a valid number
        const count = parseInt(n, 10);
        if (isNaN(count) || count <= 0) {
            console.error('Invalid number of combinations to render:', n);
            return;
        }
        
        console.log(`Rendering ${count} combinations, useFrequentTrios: ${useFrequentTrios}`);
        
        const container = document.getElementById('generated-table');
        if (!container) {
            console.error('Could not find generated-table element');
            return;
        }
        
        // Ensure container is visible and cleared
        container.style.display = 'block';
        container.style.visibility = 'visible';
        container.style.opacity = '1';
        container.innerHTML = '';
        
        // Create table element
        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.borderCollapse = 'separate';
        table.style.borderSpacing = '0 8px';
        table.style.margin = '0';
        table.style.tableLayout = 'fixed';
        
        // Create table header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        headerRow.style.backgroundColor = '#f8f9fa';
        
        // Always create the Numbers header first
        const th2 = document.createElement('th');
        th2.textContent = 'Numbers';
        th2.style.textAlign = 'left';
        th2.style.padding = '12px 8px';
        th2.style.border = 'none';
        
        // Only add border radius if there's no trio info column
        if (!useFrequentTrios && !useOverlappingTrios) {
            th2.style.borderRadius = '0 8px 8px 0';
        } else {
            th2.style.borderRadius = '8px 0 0 8px';
        }
        
        headerRow.appendChild(th2);
        
        if (useFrequentTrios) {
            const th3 = document.createElement('th');
            th3.textContent = 'Based On Trio';
            th3.style.textAlign = 'left';
            th3.style.padding = '12px 8px';
            th3.style.border = 'none';
            th3.style.borderRadius = '0 8px 8px 0';
            headerRow.appendChild(th3);
        }
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Create table body
        const tbody = document.createElement('tbody');

        for (let i = 0; i < count; i++) {
            try {
                // Create combination based on frequent or overlapping trios
                let mainNumbers, basedOnTrio = '';
                
                if (useFrequentTrios || useOverlappingTrios) {
                    const result = useOverlappingTrios 
                        ? generateFromOverlappingTrios() 
                        : generateFromFrequentTrios();
                    
                    if (result && result.combination) {
                        mainNumbers = result.combination;
                        basedOnTrio = result.basedOnTrio || '';
                    } else {
                        console.error('Failed to generate combination from trios, falling back to random');
                        mainNumbers = generateCombination().mainNumbers;
                    }
                } else {
                    mainNumbers = generateCombination().mainNumbers;
                }

                const comboCard = document.createElement('div');
                comboCard.className = 'combo-card';
                comboCard.setAttribute('data-pattern', combo.pattern);
                comboCard.setAttribute('data-trio', combo.basedOnTrio);
                comboCard.style.border = '1px solid #e0e0e0';
                comboCard.style.borderRadius = '8px';
                comboCard.style.padding = '15px';
                comboCard.style.marginBottom = '15px';
                comboCard.style.background = '#fff';
                comboCard.style.boxShadow = '0 2px 8px rgba(0,0,0,0.05)';
                comboCard.style.position = 'relative';

                const tr = document.createElement('tr');
                tr.style.display = 'table-row';
                
                // Add numbers cell
                const td2 = document.createElement('td');
                td2.textContent = mainNumbers.join(' - ');
                td2.style.padding = '12px 8px';
                td2.style.fontWeight = 'bold';
                td2.style.color = '#2c3e50';
                td2.style.border = 'none';
                td2.style.whiteSpace = 'nowrap';  // Prevent line breaks in numbers
                
                if (useFrequentTrios || useOverlappingTrios) {
                    td2.style.borderRadius = '8px 0 0 8px';  // Rounded left corners when there's a trio info column
                } else {
                    td2.style.borderRadius = '8px';  // Rounded corners when it's the only column
                }
                tr.appendChild(td2);
                
                // Add trio info if needed
                if (useFrequentTrios || useOverlappingTrios) {
                    const td3 = document.createElement('td');
                    td3.textContent = basedOnTrio;
                    td3.style.padding = '12px 8px';
                    td3.style.color = '#9b59b6';
                    td3.style.fontWeight = '500';
                    td3.style.border = 'none';
                    td3.style.borderRadius = '0 8px 8px 0';
                    tr.appendChild(td3);
                }
                
                tbody.appendChild(tr);
            } catch (error) {
                console.error(`Error generating combination ${i+1}:`, error);
            }
        }
        
        table.appendChild(tbody);
        
        // Create a wrapper div for better control
        const tableWrapper = document.createElement('div');
        tableWrapper.style.overflowX = 'auto';
        tableWrapper.style.width = '100%';
        tableWrapper.appendChild(table);
        
        // Clear and append the table
        container.innerHTML = '';
        container.appendChild(tableWrapper);
        
        // Force a reflow to ensure the table is rendered
        void container.offsetHeight;
        
        console.log('Table rendered with', count, 'combinations');
        console.log('Container dimensions:', container.offsetWidth, 'x', container.offsetHeight);
    }
    
    // Handle generate from two duos button
    document.getElementById('build-duo-combo-btn').addEventListener('click', function() {
      const duo1Key = document.getElementById('duo1-select').value;
      const duo2Key = document.getElementById('duo2-select').value;
      
      if (!duo1Key || !duo2Key) return;
      
      const combination = generateFromTwoDuos(duo1Key, duo2Key);
      const resultDiv = document.getElementById('built-duo-combo-result');
      
      // Format the result with styling and bolder numbers
      resultDiv.innerHTML = `
        <div class="result-container">
          <div class="result-title">
            <i class="fas fa-star"></i>
            <span style="font-weight: 700; font-size: 1.1em;">Generated Combination</span>
          </div>
          <div style="margin: 15px 0; display: flex; flex-wrap: wrap; gap: 5px; justify-content: center;">
            ${formatCombination(combination)}
          </div>
          <div style="font-size: 0.9em; color: #7f8c8d; margin-top: 15px; padding-top: 10px; border-top: 1px solid #eee;">
            <i class="fas fa-info-circle"></i> This combination was generated from the selected duos.
          </div>
        </div>
      `;
    });
    
    // Handle generate from duo + trio button
    document.getElementById('build-combo-btn').addEventListener('click', function() {
      const duoKey = document.getElementById('combo-duo-select').value;
      const trioKey = document.getElementById('combo-trio-select').value;
      
      if (!duoKey || !trioKey) return;
      
      const combination = generateFromDuoAndTrio(duoKey, trioKey);
      const resultDiv = document.getElementById('built-combo-result');
      
      // Get the selected duo and trio for display
      const duo = duoKey.split(':').map(n => formatNumber(parseInt(n))).join(' - ');
      const trio = trioKey.split(':').map(n => formatNumber(parseInt(n))).join(' - ');
      
      // Format the result with styling and bolder numbers
      resultDiv.innerHTML = `
        <div class="result-container">
          <div class="result-title">
            <i class="fas fa-star"></i>
            <span style="font-weight: 700; font-size: 1.1em;">Generated Combination</span>
          </div>
          <div style="margin: 15px 0; display: flex; flex-wrap: wrap; gap: 5px;justify-content: center;">
            ${formatCombination(combination)}
          </div>
          <div style="font-size: 0.95em; color: #7f8c8d; margin-top: 15px; padding-top: 10px; border-top: 1px solid #eee;">
            <div style="margin-bottom: 6px;"><i class="fas fa-random"></i> <strong style="font-weight: 700;">Source Duo:</strong> 
              <span style="font-weight: 700; color: #2c3e50;">${duo}</span>
            </div>
            <div><i class="fas fa-random"></i> <strong style="font-weight: 700;">Source Trio:</strong> 
              <span style="font-weight: 700; color: #2c3e50;">${trio}</span>
            </div>
          </div>
        </div>
      `;
    });
    
    // Handle regular number generation buttons - number-based generation removed
    
    // Handle overlapping trios button
    document.getElementById('generate-from-overlapping-trios').addEventListener('click', function() {
        renderCombinations(5, false, true);
    });

    // Track used enhanced trios for round-robin
    let usedEnhancedTrios = new Set();
    let enhancedTrioIndex = 0;

    // Enhanced trio generator function using overlapping trios
    function generateEnhancedTrioCombinations() {
        const combinations = [];
        const maxAttempts = 1000;
        let attempts = 0;
        
        // Generate 5 combinations with different patterns
        while (combinations.length < 5 && attempts < maxAttempts) {
            attempts++;
            
            // Get overlapping trios from historical data
            let overlappingResult;
            try {
                overlappingResult = generateFromOverlappingTrios();
                if (!overlappingResult || !overlappingResult.combination) {
                    console.error('Failed to generate overlapping trios');
                    continue;
                }
            } catch (error) {
                console.error('Error in generateFromOverlappingTrios:', error);
                continue;
            }
            
            // Get the base combination from overlapping trios
            const baseCombination = [...overlappingResult.combination];
            const trioKey = baseCombination.slice(0, 3).sort((a, b) => a - b).join(',');
            
            // Skip if we've used this trio before
            if (usedEnhancedTrios.has(trioKey)) continue;
            
            // Determine pattern based on combination index
            const pattern = combinations.length % 5; // Now 5 patterns (0-4)
            
            // Adjust numbers to match the desired pattern
            let adjustedCombination = [...baseCombination];
            
            // Ensure the combination matches the pattern
            switch (pattern) {
                case 0: // 2 odd, 3 even
                    adjustParity(adjustedCombination, 2, 3);
                    break;
                case 1: // 3 odd, 2 even
                    adjustParity(adjustedCombination, 3, 2);
                    break;
                case 2: // 2 low (1-39), 3 high (40-69)
                    adjustRange(adjustedCombination, 2, 3);
                    break;
                case 3: // 3 low (1-39), 2 high (40-69)
                    adjustRange(adjustedCombination, 3, 2);
                    break;
                case 4: // No double digits (1-9, 10-19, 20-29, etc.)
                    adjustedCombination = adjustedCombination.map(num => {
                        // Convert to single digit by taking modulo 9 + 1 (1-9)
                        return ((num - 1) % 9) + 1;
                    });
                    // Ensure we still have unique numbers
                    if (new Set(adjustedCombination).size < 5) continue;
                    break;
            }
            
            // Ensure no duplicates and valid range
            const uniqueNums = new Set(adjustedCombination);
            if (uniqueNums.size !== 5) continue;
            if (Math.min(...adjustedCombination) < 1 || Math.max(...adjustedCombination) > 69) continue;
            
            // Check for duplicate endings (last digit)
            const endings = adjustedCombination.map(n => n % 10);
            const uniqueEndings = new Set(endings);
            
            // Skip if we don't have at least one duplicate ending
            // Except for the no-double-digits pattern
            if (pattern !== 4 && uniqueEndings.size >= 5) continue;
            
            // Add to combinations
            combinations.push({
                numbers: [...adjustedCombination].sort((a, b) => a - b),
                powerball: getRandomInt(1, 26),
                pattern: pattern,
                basedOnTrio: overlappingResult.basedOnTrio || 'Overlapping Trios'
            });
            
            // Add to used trios for round-robin
            usedEnhancedTrios.add(trioKey);
            enhancedTrioIndex++;
            
            // Reset if we've used all trios
            if (enhancedTrioIndex >= 100) {
                usedEnhancedTrios.clear();
                enhancedTrioIndex = 0;
            }
        }
        
        // Render the combinations
        renderEnhancedCombinations(combinations);
    }
    
    // Helper function to adjust parity of numbers in a combination
    function adjustParity(combination, targetOdd, targetEven) {
        // First, count current parity
        let currentOdd = 0;
        const odds = [];
        const evens = [];
        
        // Categorize numbers
        combination.forEach((num, index) => {
            if (num % 2 !== 0) {
                currentOdd++;
                odds.push(index);
            } else {
                evens.push(index);
            }
        });
        
        // Adjust parity if needed
        if (currentOdd !== targetOdd) {
            const toChange = Math.abs(targetOdd - currentOdd);
            const sourceArray = currentOdd > targetOdd ? odds : evens;
            const targetParity = currentOdd > targetOdd ? 'even' : 'odd';
            
            // Change numbers to match target parity
            for (let i = 0; i < Math.min(toChange, sourceArray.length); i++) {
                const idx = sourceArray[i];
                combination[idx] = generateNumberWithParity(1, 69, targetParity, combination);
            }
        }
        
        // Final verification
        const finalOdds = combination.filter(n => n % 2 !== 0).length;
        if (finalOdds !== targetOdd) {
            // If still not matching, force it by regenerating the last few numbers
            const neededOdds = targetOdd - finalOdds;
            const startIdx = Math.max(0, combination.length - Math.abs(neededOdds));
            
            for (let i = startIdx; i < combination.length; i++) {
                const targetParity = neededOdds > 0 ? 'odd' : 'even';
                combination[i] = generateNumberWithParity(1, 69, targetParity, combination);
            }
        }
    }
    
    // Helper function to generate number with specific parity
    function generateNumberWithParity(min, max, parity, exclude = []) {
        const excludeSet = new Set(exclude);
        const isEven = parity === 'even';
        
        // First, try to find a suitable number in the range
        for (let i = 0; i < 100; i++) {
            const num = getRandomInt(min, max);
            if ((num % 2 === 0) === isEven && !excludeSet.has(num)) {
                return num;
            }
        }
        
        // Fallback: find any number with correct parity
        const start = isEven ? 2 : 1;
        for (let num = start; num <= max; num += 2) {
            if (!excludeSet.has(num)) {
                return num;
            }
        }
        
        // Last resort: return any number not in exclude
        for (let num = min; num <= max; num++) {
            if (!excludeSet.has(num)) {
                return num;
            }
        }
        
        // Should never get here if called with valid parameters
        return getRandomInt(min, max);
    }
    
    // Helper function to generate number within a specific range
    function generateNumberWithRange(min, max, exclude = []) {
        const excludeSet = new Set(exclude);
        
        // First, try to find a suitable number in the range
        for (let i = 0; i < 100; i++) {
            const num = getRandomInt(min, max);
            if (!excludeSet.has(num)) {
                return num;
            }
        }
        
        // Fallback: find any available number in range
        for (let num = min; num <= max; num++) {
            if (!excludeSet.has(num)) {
                return num;
            }
        }
        
        // Last resort: return any number not in exclude (even if outside range)
        for (let num = 1; num <= 69; num++) {
            if (!excludeSet.has(num)) {
                return num;
            }
        }
        
        // Should never get here if called with valid parameters
        return getRandomInt(1, 69);
    }

    // Helper function to adjust range of numbers in a combination
    function adjustRange(combination, targetLow, targetHigh) {
        // First, count current ranges
        let currentLow = 0;
        const lows = [];
        const highs = [];
        
        // Categorize numbers
        combination.forEach((num, index) => {
            if (num <= 39) {
                currentLow++;
                lows.push(index);
            } else {
                highs.push(index);
            }
        });
        
        // Adjust range if needed
        if (currentLow !== targetLow) {
            const toChange = Math.abs(targetLow - currentLow);
            const sourceArray = currentLow > targetLow ? lows : highs;
            const targetRange = currentLow > targetLow ? 'high' : 'low';
            
            // Change numbers to match target range
            for (let i = 0; i < Math.min(toChange, sourceArray.length); i++) {
                const idx = sourceArray[i];
                combination[idx] = targetRange === 'low' 
                    ? generateNumberWithRange(1, 39, combination)
                    : generateNumberWithRange(40, 69, combination);
            }
        }
        
        // Final verification and fix any duplicates
        const finalLows = combination.filter(n => n <= 39).length;
        if (finalLows !== targetLow) {
            // If still not matching, force it by regenerating the last few numbers
            const neededLows = targetLow - finalLows;
            const startIdx = Math.max(0, combination.length - Math.abs(neededLows));
            
            for (let i = startIdx; i < combination.length; i++) {
                combination[i] = neededLows > 0
                    ? generateNumberWithRange(1, 39, combination)
                    : generateNumberWithRange(40, 69, combination);
            }
        }
        
        // One final check for duplicates
        const uniqueNums = new Set(combination);
        if (uniqueNums.size < 5) {
            const used = new Set();
            for (let i = 0; i < combination.length; i++) {
                if (used.has(combination[i])) {
                    combination[i] = generateNumberWithRange(1, 69, combination);
                }
                used.add(combination[i]);
            }
        }
    }
    
    // Helper function to check if a number is a single digit
    function isSingleDigit(num) {
        return num >= 1 && num <= 9;
    }
    
    // Helper function to check if all numbers in a combination are single digits
    function hasNoDoubleDigits(combination) {
        return combination.every(num => isSingleDigit(num));
    }
    
    // Function to format combinations for download
    function formatCombinationsForDownload(combinations) {
        const patternNames = [
            '2 Odd, 3 Even',
            '3 Odd, 2 Even',
            '2 Low (1-39), 3 High (40-69)',
            '3 Low (1-39), 2 High (40-69)',
            'No Double Digits (1-9)'
        ];
        
        let text = 'Powerball Enhanced Trio Generator - Generated Combinations\n';
        text += 'Generated on: ' + new Date().toLocaleString() + '\n\n';
        
        combinations.forEach((combo, index) => {
            const patternName = patternNames[combo.pattern] || 'Custom Pattern';
            const numbers = combo.numbers.join(', ');
            const powerball = combo.powerball;
            const basedOnTrio = combo.basedOnTrio || 'Overlapping Trios';
            
            text += `Combination ${index + 1}:\n`;
            text += `Numbers: ${numbers}\n`;
            text += `Powerball: ${powerball}\n`;
            text += `Pattern: ${patternName}\n`;
            text += `Based on: ${basedOnTrio}\n`;
            text += '-----------------------------------\n\n';
        });
        
        return text;
    }
    
    // Function to download text as file
    function downloadTextAsFile(text, filename) {
        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
    
    // Render the enhanced combinations
    function renderEnhancedCombinations(combinations) {
        const container = document.getElementById('generated-table');
        if (!container) return;
        
        const patternNames = [
            '2 Odd, 3 Even',
            '3 Odd, 2 Even',
            '2 Low (1-39), 3 High (40-69)',
            '3 Low (1-39), 2 High (40-69)',
            'No Double Digits (1-9)'
        ];
        
        let html = '<div class="enhanced-combinations">';
        html += `
        <div style="margin-bottom: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; color: #2c3e50; font-size: 1.2em;">Enhanced Trio Combinations (Using Overlapping Trios)</h3>
                <button id="download-combinations" class="btn btn-primary" style="background: linear-gradient(90deg, #4CAF50 0%, #2E7D32 100%); border: none; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em; display: flex; align-items: center; gap: 5px;">
                    <i class="fas fa-download"></i> Download
                </button>
            </div>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
                <span style="background: #e8f5e9; color: #27ae60; padding: 4px 10px; border-radius: 15px; font-size: 0.85em;">
                    <i class="fas fa-sync-alt"></i> Cycling through patterns
                </span>
                <span style="background: #e3f2fd; color: #1976d2; padding: 4px 10px; border-radius: 15px; font-size: 0.85em;">
                    <i class="fas fa-random"></i> Using historical overlapping trios
                </span>
                <span style="background: #fff3e0; color: #f39c12; padding: 4px 10px; border-radius: 15px; font-size: 0.85em;">
                    <i class="fas fa-check-double"></i> Ensures duplicate endings
                </span>
            </div>
        </div>`;
        
        combinations.forEach((combo, index) => {
            const patternName = patternNames[combo.pattern];
            const endings = combo.numbers.map(n => n % 10);
            const endingCounts = endings.reduce((acc, curr) => {
                acc[curr] = (acc[curr] || 0) + 1;
                return acc;
            }, {});
            
            // Calculate stats for the combination
            const oddCount = combo.numbers.filter(n => n % 2 !== 0).length;
            const evenCount = 5 - oddCount;
            const lowCount = combo.numbers.filter(n => n <= 39).length;
            const highCount = 5 - lowCount;
            const pattern = combo.pattern || 0;
            
            // Check if this combination has been drawn before and get draw dates
            const sortedCombo = [...combo.numbers].sort((a, b) => a - b);
            const comboKey = sortedCombo.join(',');
            
            const drawnBefore = [];
            const partialMatches = [];
            
            allMainDraws.forEach(d => {
                const sortedDraw = [...d.arr].sort((a, b) => a - b);
                
                // Count how many numbers match
                const matchingNumbers = sortedCombo.filter(num => sortedDraw.includes(num));
                const matchCount = matchingNumbers.length;
                
                // If all numbers match (exact match)
                if (matchCount === 5) {
                    drawnBefore.push({
                        date: d.date || 'Unknown date',
                        numbers: sortedDraw,
                        matchType: 'exact',
                        matchCount: 5
                    });
                }
                // If 4 numbers match (partial match)
                else if (matchCount >= 4) {
                    partialMatches.push({
                        date: d.date || 'Unknown date',
                        numbers: sortedDraw,
                        matchType: 'partial',
                        matchCount: matchCount,
                        matchingNumbers: matchingNumbers
                    });
                }
            });
            
            // Show partial matches if no exact matches found
            const matchesToShow = drawnBefore.length > 0 ? drawnBefore : partialMatches;
            const isDrawnBefore = matchesToShow.length > 0;
            const drawDates = matchesToShow.map(d => {
                const matchInfo = d.matchType === 'partial' && d.matchingNumbers
                    ? ` (${d.matchCount} numbers: ${d.matchingNumbers.join(', ')})` 
                    : '';
                return d.date ? `${d.date}${matchInfo}` : null;
            }).filter(Boolean).join(', ');
            
            html += `
            <div class="combo-card" style="background: #fff; border-radius: 12px; padding: 16px; margin-bottom: 20px; box-shadow: 0 3px 10px rgba(0,0,0,0.08); border-left: 5px solid ${isDrawnBefore ? '#e74c3c' : '#2ecc70'}; position: relative;">
                <!-- Header with pattern -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px; flex-wrap: wrap; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="background: #f0f4ff; color: #3498db; padding: 5px 12px; border-radius: 15px; font-size: 0.85em; font-weight: 500;">
                            <i class="fas ${pattern === 0 || pattern === 1 ? 'fa-exchange-alt' : 'fa-arrows-alt-v'}" style="margin-right: 6px;"></i>
                            ${patternName}
                        </span>
                    </div>
                    
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; background: #f8f9fa; padding: 4px 12px; border-radius: 12px; font-size: 0.85em; border: 1px solid #e0e0e0; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
                            <span style="color: #e65100; font-weight: 600;">${oddCount} Odd</span> 
                            <span style="margin: 0 6px; color: #bdbdbd;">|</span>
                            <span style="color: #1b5e20; font-weight: 600;">${evenCount} Even</span>
                        </div>
                        <div style="display: flex; align-items: center; background: #f8f9fa; padding: 4px 12px; border-radius: 12px; font-size: 0.85em; border: 1px solid #e0e0e0; box-shadow: 0 1px 3px rgba(0,0,0,0.05);">
                            <span style="color: #b71c1c; font-weight: 600;">${lowCount} Low</span> 
                            <span style="margin: 0 6px; color: #bdbdbd;">|</span>
                            <span style="color: #0d47a1; font-weight: 600;">${highCount} High</span>
                        </div>
                    </div>
                </div>
                
                <!-- Match Info -->
                ${matchesToShow.length > 0 ? 
                    `<div style="background: #ffebee; color: #e74c3c; padding: 10px 15px; border-radius: 10px; margin: 10px 0; font-size: 0.85em;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-weight: 600;">
                            <i class="fas fa-exclamation-triangle"></i>
                            <span>Drawn ${matchesToShow.length} time${matchesToShow.length !== 1 ? 's' : ''}</span>
                        </div>
                        <div style="font-size: 0.95em; color: #b71c1c; line-height: 1.5;">
                            ${matchesToShow.map(d => {
                                const numbers = d.numbers.join(', ');
                                const matchInfo = d.matchType === 'partial' && d.matchingNumbers
                                    ? ` (${d.matchCount} matching: ${d.matchingNumbers.join(', ')})` 
                                    : '';
                                return `• ${d.date || 'Unknown date'}: ${numbers}${matchInfo}`;
                            }).join('<br>')}
                        </div>
                    </div>` : 
                    ''
                }
                
                <!-- Numbers -->
                <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin: 12px 0 16px 0;">
                ${combo.numbers.map((num, i) => {
                    const ending = endings[i];
                    const isDuplicate = endingCounts[ending] > 1;
                    const isLow = num <= 39;
                    const isOdd = num % 2 !== 0;
                    
                    // Color scheme matching indicators
                    let bgColor = isLow ? '#ffebee' : '#e3f2fd'; // Light pink for low, light blue for high
                    let textColor = isOdd ? '#e65100' : '#1b5e20'; // Dark orange for odd, dark green for even
                    let borderColor = isLow ? '#b71c1c' : '#0d47a1'; // Dark red for low, dark blue for high
                    
                    return `
                    <div style="
                        width: 40px;
                        height: 40px;
                        border-radius: 50%;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        font-weight: 700;
                        background: ${bgColor};
                        color: ${textColor};
                        border: 2px solid ${isDuplicate ? '#f1c40f' : borderColor};
                        box-shadow: ${isDuplicate ? '0 0 0 2px #f1c40f' : '0 2px 4px rgba(0,0,0,0.2)'};
                        position: relative;
                        transition: all 0.2s ease;
                    ">
                        <div style="font-size: 1.1em;">${num}</div>
                        ${isDuplicate ? `
                        <div style="
                            position: absolute;
                            top: -4px;
                            right: -4px;
                            background: #f1c40f;
                            color: #000;
                            width: 18px;
                            height: 18px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 11px;
                            font-weight: bold;
                            border: 2px solid #fff;
                            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                        ">${endingCounts[ending]}</div>` : ''}
                        <div style="
                            position: absolute;
                            bottom: -16px;
                            font-size: 10px;
                            color: ${isDuplicate ? '#f1c40f' : '#7f8c8d'};
                            font-weight: ${isDuplicate ? 'bold' : 'normal'};
                            text-shadow: ${isDuplicate ? '0 0 2px rgba(241, 196, 15, 0.3)' : 'none'};
                        ">${ending}</div>
                    </div>`;
                }).join('')}
                <div style="
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        margin-left: 4px;
                    ">
                        <div style="
                            width: 40px;
                            height: 40px;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: 700;
                            background: linear-gradient(135deg, #ff6b6b 0%, #ff4757 100%);
                            color: white;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                            position: relative;
                            z-index: 1;
                        ">
                            ${combo.powerball}
                            <div style="
                                position: absolute;
                                bottom: -16px;
                                font-size: 10px;
                                color: #ff6b6b;
                                font-weight: 600;
                            ">PB</div>
                        </div>
                    </div>
                </div>
                
                <!-- Footer with additional info -->
                <div style="display: flex; justify-content: space-between; align-items: center; padding-top: 12px; border-top: 1px solid #f0f0f0; margin-top: 8px; font-size: 0.8em; color: #7f8c8d; flex-wrap: wrap; gap: 10px;">
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <i class="fas fa-info-circle"></i>
                            <span>${Object.entries(endingCounts)
                                .filter(([_, count]) => count > 1)
                                .map(([ending, count]) => `Ending ${ending}: ${count}x`)
                                .join(', ') || 'No duplicate endings'}</span>
                        </div>
                        
                        ${isDrawnBefore ? 
                            `<div style="display: flex; align-items: center; gap: 4px; color: #e74c3c;" 
                              title="${drawDates}">
                                <i class="fas fa-history"></i> 
                                <span>Drawn: ${drawnBefore.length} time${drawnBefore.length > 1 ? 's' : ''}</span>
                            </div>` : 
                            ''
                        }
                    </div>
                    
                    <div style="color: #9b59b6; font-size: 0.85em; display: flex; align-items: center; gap: 4px;">
                        <i class="fas fa-project-diagram"></i>
                        <span>${combo.basedOnTrio || 'Overlapping trios'}</span>
                    </div>
                </div>
            </div>`;
        });
        
        html += '</div>';
        container.innerHTML = html;
    }
    
    // Add event listeners
    document.getElementById('generate-enhanced-trios')?.addEventListener('click', generateEnhancedTrioCombinations);
    
    // Add download button event listener
    document.addEventListener('click', function(e) {
        if (e.target && e.target.id === 'download-combinations') {
            const container = document.querySelector('.enhanced-combinations');
            if (!container) return;
            
            const combinations = [];
            const comboElements = container.querySelectorAll('.combo-card');
            
            comboElements.forEach(comboEl => {
                const numbers = Array.from(comboEl.querySelectorAll('.ball')).map(ball => parseInt(ball.textContent));
                const powerball = parseInt(comboEl.querySelector('.powerball')?.textContent || '0');
                const pattern = comboEl.getAttribute('data-pattern') || '0';
                const basedOnTrio = comboEl.getAttribute('data-trio') || 'Overlapping Trios';
                
                combinations.push({
                    numbers: numbers,
                    powerball: powerball,
                    pattern: parseInt(pattern),
                    basedOnTrio: basedOnTrio
                });
            });
            
            if (combinations.length > 0) {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const filename = `powerball-combinations-${timestamp}.txt`;
                const text = formatCombinationsForDownload(combinations);
                downloadTextAsFile(text, filename);
            } else {
                alert('No combinations to download. Please generate some combinations first.');
            }
        }
    });
    
    // Handle frequent trios button
    function initializeTrioButton() {
        const generateFromTriosBtn = document.getElementById('generate-from-trios');
        console.log('Trio button element:', generateFromTriosBtn);
        if (generateFromTriosBtn) {
            // Remove any existing click handlers to prevent duplicates
            const newBtn = generateFromTriosBtn.cloneNode(true);
            generateFromTriosBtn.parentNode.replaceChild(newBtn, generateFromTriosBtn);
            
            console.log('Adding click handler to trio button');
            newBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                console.log('Trio button clicked');
                console.log('sortedTriplets available:', window.sortedTriplets ? 'Yes' : 'No');
                if (window.sortedTriplets) {
                    console.log('Number of available trios:', window.sortedTriplets.length);
                    // Clear any previous error messages
                    const container = document.getElementById('generated-table');
                    if (container) {
                        container.innerHTML = '';
                    }
                    // Render new combinations
                    renderCombinations(5, true);
                } else {
                    console.error('No sortedTriplets data available');
                    const container = document.getElementById('generated-table');
                    if (container) {
                        container.innerHTML = '<div style="color: #e74c3c; padding: 15px; text-align: center;">Loading data... Please try again in a moment.</div>';
                    }
                }
            });
        } else {
            console.error('Could not find generate-from-trios button');
        }
    }
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM fully loaded');
        // Initialize the trio button
        initializeTrioButton();
        
        // Show home tab by default (guard for missing elements)
        const homeTab = document.getElementById('home-tab');
        if (homeTab) homeTab.style.display = 'block';
        const historyTab = document.getElementById('history-tab');
        if (historyTab) historyTab.style.display = 'none';
        // Do NOT call analyzeFrequentSets here. It is called after CSV loads.
        
        // Generate button handlers - number-based generation removed
        // Add clear/deselect handlers for Section 2 and 3
        const clearDuoBtn = document.getElementById('clear-duo-selection-btn');
        if (clearDuoBtn) {
            clearDuoBtn.onclick = function() {
                const duo1Select = document.getElementById('duo1-select');
                const duo2Select = document.getElementById('duo2-select');
                duo1Select.selectedIndex = -1;
                duo2Select.selectedIndex = -1;
                document.getElementById('built-duo-combo-result').innerHTML = '';
                document.getElementById('build-duo-combo-btn').disabled = true;
            };
        }
        const clearComboBtn = document.getElementById('clear-combo-selection-btn');
        if (clearComboBtn) {
            clearComboBtn.onclick = function() {
                const comboDuoSelect = document.getElementById('combo-duo-select');
                const comboTrioSelect = document.getElementById('combo-trio-select');
                comboDuoSelect.selectedIndex = -1;
                comboTrioSelect.selectedIndex = -1;
                document.getElementById('built-combo-result').innerHTML = '';
                document.getElementById('build-combo-btn').disabled = true;
            };
        }

        // Tab switching logic
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                // Remove active class from all buttons
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                // Add active class to clicked button
                this.classList.add('active');
                
                // For history tab
                if (this.getAttribute('data-tab') === 'history') {
                    document.getElementById('home-tab').style.display = 'none';
                    document.getElementById('history-tab').style.display = 'block';
                    renderHistoryTable();
                } else {
                    document.getElementById('home-tab').style.display = 'block';
                    document.getElementById('history-tab').style.display = 'none';
                }
            });
        });

        // Add event listener for building combinations from duos
        const buildDuoBtn = document.getElementById('build-duo-combo-btn');
        if (buildDuoBtn) {
            buildDuoBtn.addEventListener('click', function() {
                const duo1Val = document.getElementById('duo1-select').value;
                const duo2Val = document.getElementById('duo2-select').value;
                if (!duo1Val || !duo2Val) {
                    alert('Please select two valid duos to combine');
                    return;
                }
                const duo1 = duo1Val.split('-').map(Number);
                const duo2 = duo2Val.split('-').map(Number);
                if (duo1.length === 2 && duo2.length === 2) {
                    const combined = [...new Set([...duo1, ...duo2])];
                    if (combined.length === 4) {
                        const result = document.getElementById('built-duo-combo-result');
                        result.innerHTML = `
                            <div class="result-card fade-in">
                                <div class="result-title">Generated Combination</div>
                                <div class="result-balls">
                                    ${combined.sort((a,b) => a-b).map(n => `<span class='generated-ball'>${n}</span>`).join(' ')}
                                </div>
                            </div>
                        `;
                        return;
                    }
                }
                alert('Please select two valid duos to combine');
            });
            // Enable/disable build button logic
            const duo1Select = document.getElementById('duo1-select');
            const duo2Select = document.getElementById('duo2-select');
            [duo1Select, duo2Select].forEach(sel => sel.addEventListener('change', function() {
                buildDuoBtn.disabled = !(duo1Select.value && duo2Select.value);
            }));
        }
        // Section 3: Combo build button logic
        const buildComboBtn = document.getElementById('build-combo-btn');
        if (buildComboBtn) {
            buildComboBtn.addEventListener('click', function() {
                const duoVal = document.getElementById('combo-duo-select').value;
                const trioVal = document.getElementById('combo-trio-select').value;
                if (!duoVal || !trioVal) {
                    alert('Please select a valid duo and trio to combine');
                    return;
                }
                const duo = duoVal.split('-').map(Number);
                const trio = trioVal.split('-').map(Number);
                if (duo.length === 2 && trio.length === 3) {
                    const combined = [...new Set([...duo, ...trio])];
                    if (combined.length === 5) {
                        const result = document.getElementById('built-combo-result');
                        result.innerHTML = `
    <div class="result-card fade-in">
        <div class="result-title">Generated Combination</div>
        <div class="result-balls">
            ${combined.sort((a,b) => a-b).map(n => `<span class='generated-ball'>${n}</span>`).join(' ')}
        </div>
    </div>
`;
                        return;
                    }
                }
                alert('Please select a valid duo and trio to combine');
            });
            // Enable/disable build button logic
            const comboDuoSelect = document.getElementById('combo-duo-select');
            const comboTrioSelect = document.getElementById('combo-trio-select');
            [comboDuoSelect, comboTrioSelect].forEach(sel => sel.addEventListener('change', function() {
                buildComboBtn.disabled = !(comboDuoSelect.value && comboTrioSelect.value);
            }));
        }
    });

    // History tab rendering
    function renderHistoryTable() {
        const historyContent = document.getElementById('history-content');
        if (!historyContent) return;
        
        let html = '<table class="freq-table" style="width:100%;"><thead><tr><th>#</th><th>Numbers</th></tr></thead><tbody>';
        allMainDraws.forEach((nums, idx) => {
            html += `<tr><td>${idx+1}</td><td><div class="aligned-numbers">${nums.map((num, i) => `<span class='plain-number'>${num}</span>${i < nums.length - 1 ? '<b style=\"color:#000;font-size:1.2em;\">-</b>' : ''}`).join('')}</div></td></tr>`;
        });
        html += '</tbody></table>';
        historyContent.innerHTML = html;
    }

    // Function to analyze frequent sets and populate dropdowns
    function analyzeFrequentSets() {
        console.log('Starting analyzeFrequentSets...');
        // Analyze and track actual trios that appeared together in a single draw
        const actualTrios = new Map(); // Store actual trios from draws
        const pairCounts = new Map();
        const tripletCounts = new Map();
        console.log('Number of draws to analyze:', allMainDraws.length);
        
        // First pass: Collect all actual trios that appeared together
        const filteredDraws = allMainDraws.filter(d => d.year >= 2016 && d.year <= 2025);
        filteredDraws.forEach(drawObj => {
            const sortedDraw = [...drawObj.arr].sort((a, b) => a - b);
            
            // Track all trios that actually appeared together in this draw
            for (let i = 0; i < sortedDraw.length - 2; i++) {
                for (let j = i + 1; j < sortedDraw.length - 1; j++) {
                    for (let k = j + 1; k < sortedDraw.length; k++) {
                        const trio = [sortedDraw[i], sortedDraw[j], sortedDraw[k]];
                        const trioKey = trio.join('-');
                        actualTrios.set(trioKey, true);
                    }
                }
            }
        });
        
        console.log('Found', actualTrios.size, 'unique trios that appeared in actual draws');
        
        // Second pass: Count frequencies of actual trios
        filteredDraws.forEach(drawObj => {
            const sortedDraw = [...drawObj.arr].sort((a, b) => a - b);
            
            // Count pairs (for other functionality)
            for (let i = 0; i < sortedDraw.length; i++) {
                for (let j = i + 1; j < sortedDraw.length; j++) {
                    const pair = [sortedDraw[i], sortedDraw[j]];
                    const pairKey = pair.join('-');
                    pairCounts.set(pairKey, (pairCounts.get(pairKey) || 0) + 1);
                }
            }
            
            // Only count trios that we've seen in actual draws
            const seenTrios = new Set(); // Avoid counting same trio multiple times in one draw
            for (let i = 0; i < sortedDraw.length - 2; i++) {
                for (let j = i + 1; j < sortedDraw.length - 1; j++) {
                    for (let k = j + 1; k < sortedDraw.length; k++) {
                        const trio = [sortedDraw[i], sortedDraw[j], sortedDraw[k]];
                        const trioKey = trio.join('-');
                        if (actualTrios.has(trioKey) && !seenTrios.has(trioKey)) {
                            tripletCounts.set(trioKey, (tripletCounts.get(trioKey) || 0) + 1);
                            seenTrios.add(trioKey);
                        }
                    }
                }
            }
        });
        
        // Convert to arrays and sort by frequency (descending)
        const sortedPairs = Array.from(pairCounts.entries())
            .filter(([_, count]) => count >= 1)  // Include all actual pairs
            .sort((a, b) => b[1] - a[1]);
            
        // Only include trios that actually appeared together in a draw
        window.sortedTriplets = Array.from(tripletCounts.entries())
            .filter(([trioKey, count]) => actualTrios.has(trioKey) && count >= 1)  // Only actual trios that appeared at least once
            .sort((a, b) => b[1] - a[1]);
            
        console.log('Found', sortedPairs.length, 'frequent pairs and', window.sortedTriplets.length, 'frequent trios');
        
        // Populate duo select dropdowns with improved UI
        const duo1Select = document.getElementById('duo1-select');
        const duo2Select = document.getElementById('duo2-select');
        const comboDuoSelect = document.getElementById('combo-duo-select');
        const comboTrioSelect = document.getElementById('combo-trio-select');
        
        // Section 2: Populate duo dropdowns
        if (duo1Select && duo2Select) {
            duo1Select.innerHTML = '<option value="">Select First Duo</option>';
            duo2Select.innerHTML = '<option value="">Select Second Duo</option>';
            sortedPairs.forEach(([pairKey, count]) => {
                const option1 = document.createElement('option');
                option1.value = pairKey;
                option1.textContent = `${pairKey.replace(/-/g, ' - ')} (${count}×)`;
                option1.style.fontWeight = '700'; // Make numbers bolder
                duo1Select.appendChild(option1.cloneNode(true));
                duo2Select.appendChild(option1);
            });
            duo1Select.selectedIndex = -1;
            duo2Select.selectedIndex = -1; // No selection by default
        }
        // Section 3: Populate duo and trio dropdowns
        if (comboDuoSelect && comboTrioSelect) {
            comboDuoSelect.innerHTML = '<option value="">Select Duo</option>';
            comboTrioSelect.innerHTML = '<option value="">Select Trio</option>';
            sortedPairs.forEach(([pairKey, count]) => {
                const option = document.createElement('option');
                option.value = pairKey;
                option.textContent = `${pairKey.replace(/-/g, ' - ')} (${count}×)`;
                option.style.fontWeight = '700'; // Make numbers bolder
                comboDuoSelect.appendChild(option);
            });
            sortedTriplets.forEach(([trioKey, count]) => {
                const option = document.createElement('option');
                option.value = trioKey;
                option.textContent = `${trioKey.replace(/-/g, ' - ')} (${count}×)`;
                option.style.fontWeight = '700'; // Make numbers bolder
                comboTrioSelect.appendChild(option);
            });
            comboDuoSelect.selectedIndex = -1;
            comboTrioSelect.selectedIndex = -1; // No selection by default
        }
            // Initialize Choices.js on all dropdowns (only once)
        [duo1Select, duo2Select, comboDuoSelect, comboTrioSelect].forEach(sel => {
            if (sel && !sel.classList.contains('choices-initialized')) {
                // Create a simple select element without Choices.js
                sel.style.display = 'block';
                sel.style.width = '100%';
                sel.style.padding = '8px';
                sel.style.borderRadius = '4px';
                sel.style.border = '1px solid #ddd';
                sel.style.marginBottom = '10px';
                
                // Add search input above the select
                const searchContainer = document.createElement('div');
                searchContainer.style.marginBottom = '8px';
                
                const searchInput = document.createElement('input');
                searchInput.type = 'text';
                searchInput.placeholder = 'Search for a number...';
                searchInput.style.width = '100%';
                searchInput.style.padding = '8px';
                searchInput.style.border = '1px solid #ddd';
                searchInput.style.borderRadius = '4px';
                
                // Store original options
                const originalOptions = Array.from(sel.options);
                
                // Add event listener for search
                searchInput.addEventListener('input', function(e) {
                    const searchTerm = e.target.value.trim();
                    
                    // Clear current options
                    while (sel.options.length > 0) {
                        sel.remove(0);
                    }
                    
                    // Add default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = sel.getAttribute('data-placeholder') || 'Select an option';
                    sel.appendChild(defaultOption);
                    
                    // Filter and add matching options
                    if (searchTerm === '') {
                        // Show all options if search is empty
                        originalOptions.forEach(opt => {
                            if (opt.value !== '') {
                                sel.appendChild(opt.cloneNode(true));
                            }
                        });
                    } else if (/^\d+$/.test(searchTerm)) {
                        // Only filter if search term is a number
                        originalOptions.forEach(opt => {
                            if (opt.value === '') return;
                            
                            // Check if any number in the option matches exactly
                            const numbers = opt.value.split('-');
                            if (numbers.includes(searchTerm)) {
                                sel.appendChild(opt.cloneNode(true));
                            }
                        });
                    }
                    
                    // Trigger change event
                    const event = new Event('change');
                    sel.dispatchEvent(event);
                });
                
                // Add elements to the DOM
                searchContainer.appendChild(searchInput);
                sel.parentNode.insertBefore(searchContainer, sel);
                sel.classList.add('choices-initialized');
            }
        });
        // Add a count of available pairs
        const pairCountElement = document.createElement('div');
            pairCountElement.style.fontSize = '0.9em';
            pairCountElement.style.color = '#4a5568';
            pairCountElement.style.marginTop = '8px';
            pairCountElement.textContent = `Showing ${sortedPairs.length} frequent pairs (appearing 2+ times)`;
            duo1Select.parentNode.insertBefore(pairCountElement, duo1Select.nextSibling);
            // Enable the build button when both duos are selected
            const buildDuoBtn = document.getElementById('build-duo-combo-btn');
            if (buildDuoBtn) {
                const updateBuildButtonState = () => {
                    buildDuoBtn.disabled = !(duo1Select.value && duo2Select.value);
                };
                duo1Select.addEventListener('change', updateBuildButtonState);
                duo2Select.addEventListener('change', updateBuildButtonState);
            }
        }
    
    </script>
    <script>
    // Defer non-critical JavaScript loading
    document.addEventListener('DOMContentLoaded', function() {
        // Load Choices.js after the page is interactive
        const choicesScript = document.createElement('script');
        choicesScript.src = 'https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js';
        choicesScript.onload = function() {
            console.log('Choices.js loaded');
            // Initialize any Choices.js instances here if needed
        };
        document.body.appendChild(choicesScript);

        // Optimize touch interactions
        document.documentElement.style.touchAction = 'manipulation';
        
        // Add passive event listeners for better scrolling performance
        const addPassiveEventListener = (element, event, handler) => {
            const supportsPassive = false;
            try {
                const opts = Object.defineProperty({}, 'passive', {
                    get: function() { supportsPassive = true; }
                });
                window.addEventListener('test', null, opts);
                window.removeEventListener('test', null, opts);
            } catch (e) {}
            
            element.addEventListener(event, handler, supportsPassive ? { passive: true } : false);
        };

        // Optimize window resize
        let resizeTimeout;
        addPassiveEventListener(window, 'resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                // Handle resize logic here if needed
            }, 250);
        });

        // Optimize scroll performance
        addPassiveEventListener(window, 'scroll', function() {
            // Handle scroll logic here if needed
        }, { passive: true });

        // Optimize button clicks for mobile
        document.querySelectorAll('button, a, [role="button"]').forEach(button => {
            button.style.webkitTapHighlightColor = 'transparent';
            button.addEventListener('touchstart', function() {
                this.classList.add('active');
            }, { passive: true });
            button.addEventListener('touchend', function() {
                this.classList.remove('active');
            }, { passive: true });
        });
    });

    // Optimize animation frame usage
    (function() {
        let lastScrollTop = 0;
        const delta = 5;
        
        function checkScroll() {
            const st = window.scrollY;
            
            if (Math.abs(lastScrollTop - st) <= delta) {
                return; // No significant scroll
            }
            
            // Handle scroll direction
            if (st > lastScrollTop && st > 0) {
                // Scrolling down
            } else {
                // Scrolling up
            }
            
            lastScrollTop = st <= 0 ? 0 : st;
        }
        
        // Throttle the scroll event
        let ticking = false;
        window.addEventListener('scroll', function() {
            if (!ticking) {
                window.requestAnimationFrame(function() {
                    checkScroll();
                    ticking = false;
                });
                ticking = true;
            }
        }, { passive: true });
    })();
    </script>
</body>
</html>